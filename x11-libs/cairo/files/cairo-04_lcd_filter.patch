diff -Naur cairo-1.8.4-debian-1/src/cairo-font-options.c cairo-1.8.4-debian-2/src/cairo-font-options.c
--- cairo-1.8.4-debian-1/src/cairo-font-options.c	2008-12-04 19:42:59.000000000 +0100
+++ cairo-1.8.4-debian-2/src/cairo-font-options.c	2008-12-04 19:47:47.000000000 +0100
@@ -39,6 +39,7 @@
 static const cairo_font_options_t _cairo_font_options_nil = {
     CAIRO_ANTIALIAS_DEFAULT,
     CAIRO_SUBPIXEL_ORDER_DEFAULT,
+    CAIRO_LCD_FILTER_DEFAULT,
     CAIRO_HINT_STYLE_DEFAULT,
     CAIRO_HINT_METRICS_DEFAULT
 };
@@ -54,6 +55,7 @@
 {
     options->antialias = CAIRO_ANTIALIAS_DEFAULT;
     options->subpixel_order = CAIRO_SUBPIXEL_ORDER_DEFAULT;
+    options->lcd_filter = CAIRO_LCD_FILTER_DEFAULT;
     options->hint_style = CAIRO_HINT_STYLE_DEFAULT;
     options->hint_metrics = CAIRO_HINT_METRICS_DEFAULT;
 }
@@ -64,6 +66,7 @@
 {
     options->antialias = other->antialias;
     options->subpixel_order = other->subpixel_order;
+    options->lcd_filter = other->lcd_filter;
     options->hint_style = other->hint_style;
     options->hint_metrics = other->hint_metrics;
 }
@@ -189,6 +192,8 @@
 	options->antialias = other->antialias;
     if (other->subpixel_order != CAIRO_SUBPIXEL_ORDER_DEFAULT)
 	options->subpixel_order = other->subpixel_order;
+    if (other->lcd_filter != CAIRO_LCD_FILTER_DEFAULT)
+	options->lcd_filter = other->lcd_filter;
     if (other->hint_style != CAIRO_HINT_STYLE_DEFAULT)
 	options->hint_style = other->hint_style;
     if (other->hint_metrics != CAIRO_HINT_METRICS_DEFAULT)
@@ -221,6 +226,7 @@
 
     return (options->antialias == other->antialias &&
 	    options->subpixel_order == other->subpixel_order &&
+	    options->lcd_filter == other->lcd_filter &&
 	    options->hint_style == other->hint_style &&
 	    options->hint_metrics == other->hint_metrics);
 }
@@ -246,7 +252,8 @@
 
     return ((options->antialias) |
 	    (options->subpixel_order << 4) |
-	    (options->hint_style << 8) |
+	    (options->lcd_filter << 8) |
+	    (options->hint_style << 12) |
 	    (options->hint_metrics << 16));
 }
 slim_hidden_def (cairo_font_options_hash);
@@ -328,6 +335,48 @@
 }
 
 /**
+ * _cairo_font_options_set_lcd_filter:
+ * @options: a #cairo_font_options_t
+ * @lcd_filter: the new LCD filter
+ *
+ * Sets the LCD filter for the font options object. The LCD filter
+ * specifies how pixels are filtered when rendered with an antialiasing
+ * mode of %CAIRO_ANTIALIAS_SUBPIXEL. See the documentation for
+ * #cairo_lcd_filter_t for full details.
+ *
+ * Since: 1.8
+ **/
+void
+_cairo_font_options_set_lcd_filter (cairo_font_options_t *options,
+				    cairo_lcd_filter_t    lcd_filter)
+{
+    if (cairo_font_options_status (options))
+	return;
+
+    options->lcd_filter = lcd_filter;
+}
+
+/**
+ * _cairo_font_options_get_lcd_filter:
+ * @options: a #cairo_font_options_t
+ *
+ * Gets the LCD filter for the font options object.
+ * See the documentation for #cairo_lcd_filter_t for full details.
+ *
+ * Return value: the LCD filter for the font options object
+ *
+ * Since: 1.8
+ **/
+cairo_lcd_filter_t
+_cairo_font_options_get_lcd_filter (const cairo_font_options_t *options)
+{
+    if (cairo_font_options_status ((cairo_font_options_t *) options))
+	return CAIRO_LCD_FILTER_DEFAULT;
+
+    return options->lcd_filter;
+}
+
+/**
  * cairo_font_options_set_hint_style:
  * @options: a #cairo_font_options_t
  * @hint_style: the new hint style
diff -Naur cairo-1.8.4-debian-1/src/cairo-ft-font.c cairo-1.8.4-debian-2/src/cairo-ft-font.c
--- cairo-1.8.4-debian-1/src/cairo-ft-font.c	2008-12-04 19:42:59.000000000 +0100
+++ cairo-1.8.4-debian-2/src/cairo-ft-font.c	2008-12-04 19:47:47.000000000 +0100
@@ -57,6 +57,30 @@
 #include FT_SYNTHESIS_H
 #endif
 
+#if HAVE_FT_LIBRARY_SETLCDFILTER
+#include FT_LCD_FILTER_H
+#endif
+
+/* Fontconfig version older than 2.6 didn't have these options */
+#ifndef FC_LCD_FILTER
+#define FC_LCD_FILTER	"lcdfilter"
+#endif
+/* Some Ubuntu versions defined FC_LCD_FILTER without defining the following */
+#ifndef FC_LCD_NONE
+#define FC_LCD_NONE	0
+#define FC_LCD_DEFAULT	1
+#define FC_LCD_LIGHT	2
+#define FC_LCD_LEGACY	3
+#endif
+
+/* FreeType version older than 2.3.5(?) didn't have these options */
+#ifndef FT_LCD_FILTER_NONE
+#define FT_LCD_FILTER_NONE	0
+#define FT_LCD_FILTER_DEFAULT	1
+#define FT_LCD_FILTER_LIGHT	2
+#define FT_LCD_FILTER_LEGACY	16
+#endif
+
 #define DOUBLE_TO_26_6(d) ((FT_F26Dot6)((d) * 64.0))
 #define DOUBLE_FROM_26_6(t) ((double)(t) / 64.0)
 #define DOUBLE_TO_16_16(d) ((FT_Fixed)((d) * 65536.0))
@@ -737,23 +761,286 @@
     return CAIRO_STATUS_SUCCESS;
 }
 
-/* Empirically-derived subpixel filtering values thanks to Keith
- * Packard and libXft. */
-static const int    filters[3][3] = {
-    /* red */
-#if 0
-    {    65538*4/7,65538*2/7,65538*1/7 },
-    /* green */
-    {    65536*1/4, 65536*2/4, 65537*1/4 },
-    /* blue */
-    {    65538*1/7,65538*2/7,65538*4/7 },
+/* we sometimes need to convert the glyph bitmap in a FT_GlyphSlot
+ * into a different format. For example, we want to convert a
+ * FT_PIXEL_MODE_LCD or FT_PIXEL_MODE_LCD_V bitmap into a 32-bit
+ * ARGB or ABGR bitmap.
+ *
+ * this function prepares a target descriptor for this operation.
+ *
+ * input :: target bitmap descriptor. The function will set its
+ *          'width', 'rows' and 'pitch' fields, and only these
+ *
+ * slot  :: the glyph slot containing the source bitmap. this
+ *          function assumes that slot->format == FT_GLYPH_FORMAT_BITMAP
+ *
+ * mode  :: the requested final rendering mode. supported values are
+ *          MONO, NORMAL (i.e. gray), LCD and LCD_V
+ *
+ * the function returns the size in bytes of the corresponding buffer,
+ * it's up to the caller to allocate the corresponding memory block
+ * before calling _fill_xrender_bitmap
+ *
+ * it also returns -1 in case of error (e.g. incompatible arguments,
+ * like trying to convert a gray bitmap into a monochrome one)
+ */
+static int
+_compute_xrender_bitmap_size(FT_Bitmap      *target,
+			     FT_GlyphSlot    slot,
+			     FT_Render_Mode  mode)
+{
+    FT_Bitmap *ftbit;
+    int width, height, pitch;
+
+    if (slot->format != FT_GLYPH_FORMAT_BITMAP)
+	return -1;
+
+    /* compute the size of the final bitmap */
+    ftbit = &slot->bitmap;
+
+    width = ftbit->width;
+    height = ftbit->rows;
+    pitch = (width + 3) & ~3;
+
+    switch (ftbit->pixel_mode) {
+    case FT_PIXEL_MODE_MONO:
+	if (mode == FT_RENDER_MODE_MONO) {
+	    pitch = (((width + 31) & ~31) >> 3);
+	    break;
+	}
+	/* fall-through */
+
+    case FT_PIXEL_MODE_GRAY:
+	if (mode == FT_RENDER_MODE_LCD ||
+	    mode == FT_RENDER_MODE_LCD_V)
+	{
+	    /* each pixel is replicated into a 32-bit ARGB value */
+	    pitch = width * 4;
+	}
+	break;
+
+    case FT_PIXEL_MODE_LCD:
+	if (mode != FT_RENDER_MODE_LCD)
+	    return -1;
+
+	/* horz pixel triplets are packed into 32-bit ARGB values */
+	width /= 3;
+	pitch = width * 4;
+	break;
+
+    case FT_PIXEL_MODE_LCD_V:
+	if (mode != FT_RENDER_MODE_LCD_V)
+	    return -1;
+
+	/* vert pixel triplets are packed into 32-bit ARGB values */
+	height /= 3;
+	pitch = width * 4;
+	break;
+
+    default:  /* unsupported source format */
+	return -1;
+    }
+
+    target->width = width;
+    target->rows = height;
+    target->pitch = pitch;
+    target->buffer = NULL;
+
+    return pitch * height;
+}
+
+/* this functions converts the glyph bitmap found in a FT_GlyphSlot
+ * into a different format (see _compute_xrender_bitmap_size)
+ *
+ * you should call this function after _compute_xrender_bitmap_size
+ *
+ * target :: target bitmap descriptor. Note that its 'buffer' pointer
+ *           must point to memory allocated by the caller
+ *
+ * slot   :: the glyph slot containing the source bitmap
+ *
+ * mode   :: the requested final rendering mode
+ *
+ * bgr    :: boolean, set if BGR or VBGR pixel ordering is needed
+ */
+static void
+_fill_xrender_bitmap(FT_Bitmap      *target,
+		     FT_GlyphSlot    slot,
+		     FT_Render_Mode  mode,
+		     int             bgr)
+{
+    FT_Bitmap *ftbit = &slot->bitmap;
+    unsigned char *srcLine = ftbit->buffer;
+    unsigned char *dstLine = target->buffer;
+    int src_pitch = ftbit->pitch;
+    int width = target->width;
+    int height = target->rows;
+    int pitch = target->pitch;
+    int subpixel;
+    int h;
+
+    subpixel = (mode == FT_RENDER_MODE_LCD ||
+		mode == FT_RENDER_MODE_LCD_V);
+
+    if (src_pitch < 0)
+	srcLine -= src_pitch * (ftbit->rows - 1);
+
+    target->pixel_mode = ftbit->pixel_mode;
+
+    switch (ftbit->pixel_mode) {
+    case FT_PIXEL_MODE_MONO:
+	if (subpixel) {
+	    /* convert mono to ARGB32 values */
+
+	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
+		int x;
+
+		for (x = 0; x < width; x++) {
+		    if (srcLine[(x >> 3)] & (0x80 >> (x & 7)))
+			((unsigned int *) dstLine)[x] = 0xffffffffU;
+		}
+	    }
+	    target->pixel_mode = FT_PIXEL_MODE_LCD;
+
+	} else if (mode == FT_RENDER_MODE_NORMAL) {
+	    /* convert mono to 8-bit gray */
+
+	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
+		int x;
+
+		for (x = 0; x < width; x++) {
+		    if (srcLine[(x >> 3)] & (0x80 >> (x & 7)))
+			dstLine[x] = 0xff;
+		}
+	    }
+	    target->pixel_mode = FT_PIXEL_MODE_GRAY;
+
+	} else {
+	    /* copy mono to mono */
+
+	    int  bytes = (width + 7) >> 3;
+
+	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch)
+		memcpy (dstLine, srcLine, bytes);
+	}
+	break;
+
+    case FT_PIXEL_MODE_GRAY:
+	if (subpixel) {
+	    /* convert gray to ARGB32 values */
+
+	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
+		int x;
+		unsigned int *dst = (unsigned int *) dstLine;
+
+		for (x = 0; x < width; x++) {
+		    unsigned int pix = srcLine[x];
+
+		    pix |= (pix << 8);
+		    pix |= (pix << 16);
+
+		    dst[x] = pix;
+		}
+	    }
+	    target->pixel_mode = FT_PIXEL_MODE_LCD;
+        } else {
+            /* copy gray into gray */
+
+            for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch)
+                memcpy (dstLine, srcLine, width);
+        }
+        break;
+
+    case FT_PIXEL_MODE_LCD:
+	if (!bgr) {
+	    /* convert horizontal RGB into ARGB32 */
+
+	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
+		int x;
+		unsigned char *src = srcLine;
+		unsigned int *dst = (unsigned int *) dstLine;
+
+		for (x = 0; x < width; x++, src += 3) {
+		    unsigned int  pix;
+
+		    pix = ((unsigned int)src[0] << 16) |
+			  ((unsigned int)src[1] <<  8) |
+			  ((unsigned int)src[2]      ) |
+			  ((unsigned int)src[1] << 24) ;
+
+		    dst[x] = pix;
+		}
+	    }
+	} else {
+	    /* convert horizontal BGR into ARGB32 */
+
+	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
+
+		int x;
+		unsigned char *src = srcLine;
+		unsigned int *dst = (unsigned int *) dstLine;
+
+		for (x = 0; x < width; x++, src += 3) {
+		    unsigned int  pix;
+
+		    pix = ((unsigned int)src[2] << 16) |
+			  ((unsigned int)src[1] <<  8) |
+			  ((unsigned int)src[0]      ) |
+			  ((unsigned int)src[1] << 24) ;
+
+		    dst[x] = pix;
+		}
+	    }
+	}
+	break;
+
+    default:  /* FT_PIXEL_MODE_LCD_V */
+	/* convert vertical RGB into ARGB32 */
+	if (!bgr) {
+
+	    for (h = height; h > 0; h--, srcLine += 3 * src_pitch, dstLine += pitch) {
+		int x;
+		unsigned char* src = srcLine;
+		unsigned int*  dst = (unsigned int *) dstLine;
+
+		for (x = 0; x < width; x++, src += 1) {
+		    unsigned int pix;
+#if 1
+		    pix = ((unsigned int)src[0]           << 16) |
+			  ((unsigned int)src[src_pitch]   <<  8) |
+			  ((unsigned int)src[src_pitch*2]      ) |
+			  0xFF000000 ;
+#else
+		    pix = ((unsigned int)src[0]           << 16) |
+			  ((unsigned int)src[src_pitch]   <<  8) |
+			  ((unsigned int)src[src_pitch*2]      ) |
+			  ((unsigned int)src[src_pitch]   << 24) ;
 #endif
-    {    65538*9/13,65538*3/13,65538*1/13 },
-    /* green */
-    {    65538*1/6, 65538*4/6, 65538*1/6 },
-    /* blue */
-    {    65538*1/13,65538*3/13,65538*9/13 },
-};
+		    dst[x] = pix;
+		}
+	    }
+	} else {
+
+	    for (h = height; h > 0; h--, srcLine += 3*src_pitch, dstLine += pitch) {
+		int x;
+		unsigned char *src = srcLine;
+		unsigned int *dst = (unsigned int *) dstLine;
+
+		for (x = 0; x < width; x++, src += 1) {
+		    unsigned int  pix;
+
+		    pix = ((unsigned int)src[src_pitch * 2] << 16) |
+			  ((unsigned int)src[src_pitch]     <<  8) |
+			  ((unsigned int)src[0]                  ) |
+			  ((unsigned int)src[src_pitch]     << 24) ;
+
+		    dst[x] = pix;
+		}
+	    }
+	}
+    }
+}
+
 
 /* Fills in val->image with an image surface created from @bitmap
  */
@@ -766,7 +1053,7 @@
     int width, height, stride;
     unsigned char *data;
     int format = CAIRO_FORMAT_A8;
-    cairo_bool_t subpixel = FALSE;
+    cairo_image_surface_t *image;
 
     width = bitmap->width;
     height = bitmap->rows;
@@ -823,11 +1110,7 @@
     case FT_PIXEL_MODE_LCD:
     case FT_PIXEL_MODE_LCD_V:
     case FT_PIXEL_MODE_GRAY:
-	switch (font_options->antialias) {
-	case CAIRO_ANTIALIAS_DEFAULT:
-	case CAIRO_ANTIALIAS_GRAY:
-	case CAIRO_ANTIALIAS_NONE:
-	default:
+        if (font_options->antialias != CAIRO_ANTIALIAS_SUBPIXEL) {
 	    stride = bitmap->pitch;
 	    if (own_buffer) {
 		data = bitmap->buffer;
@@ -839,104 +1122,16 @@
 		memcpy (data, bitmap->buffer, stride * height);
 	    }
 	    format = CAIRO_FORMAT_A8;
-	    break;
-	case CAIRO_ANTIALIAS_SUBPIXEL: {
-	    int		    x, y;
-	    unsigned char   *in_line, *out_line, *in;
-	    unsigned int    *out;
-	    unsigned int    red, green, blue;
-	    int		    rf, gf, bf;
-	    int		    s;
-	    int		    o, os;
-	    unsigned char   *data_rgba;
-	    unsigned int    width_rgba, stride_rgba;
-	    int		    vmul = 1;
-	    int		    hmul = 1;
+	} else {
+	    /* if we get there, the  data from the source bitmap
+	     * really comes from _fill_xrender_bitmap, and is
+	     * made of 32-bit ARGB or ABGR values */
+	    assert (own_buffer != 0);
+	    assert (bitmap->pixel_mode != FT_PIXEL_MODE_GRAY);
 
-	    switch (font_options->subpixel_order) {
-	    case CAIRO_SUBPIXEL_ORDER_DEFAULT:
-	    case CAIRO_SUBPIXEL_ORDER_RGB:
-	    case CAIRO_SUBPIXEL_ORDER_BGR:
-	    default:
-		width /= 3;
-		hmul = 3;
-		break;
-	    case CAIRO_SUBPIXEL_ORDER_VRGB:
-	    case CAIRO_SUBPIXEL_ORDER_VBGR:
-		vmul = 3;
-		height /= 3;
-		break;
-	    }
-	    /*
-	     * Filter the glyph to soften the color fringes
-	     */
-	    width_rgba = width;
+	    data = bitmap->buffer;
 	    stride = bitmap->pitch;
-	    stride_rgba = (width_rgba * 4 + 3) & ~3;
-	    data_rgba = calloc (stride_rgba, height);
-	    if (data_rgba == NULL) {
-		if (own_buffer)
-		    free (bitmap->buffer);
-		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
-	    }
-
-	    os = 1;
-	    switch (font_options->subpixel_order) {
-	    case CAIRO_SUBPIXEL_ORDER_VRGB:
-		os = stride;
-	    case CAIRO_SUBPIXEL_ORDER_DEFAULT:
-	    case CAIRO_SUBPIXEL_ORDER_RGB:
-	    default:
-		rf = 0;
-		gf = 1;
-		bf = 2;
-		break;
-	    case CAIRO_SUBPIXEL_ORDER_VBGR:
-		os = stride;
-	    case CAIRO_SUBPIXEL_ORDER_BGR:
-		bf = 0;
-		gf = 1;
-		rf = 2;
-		break;
-	    }
-	    in_line = bitmap->buffer;
-	    out_line = data_rgba;
-	    for (y = 0; y < height; y++)
-	    {
-		in = in_line;
-		out = (unsigned int *) out_line;
-		in_line += stride * vmul;
-		out_line += stride_rgba;
-		for (x = 0; x < width * hmul; x += hmul)
-		{
-		    red = green = blue = 0;
-		    o = 0;
-		    for (s = 0; s < 3; s++)
-		    {
-			red += filters[rf][s]*in[x+o];
-			green += filters[gf][s]*in[x+o];
-			blue += filters[bf][s]*in[x+o];
-			o += os;
-		    }
-		    red = red / 65536;
-		    green = green / 65536;
-		    blue = blue / 65536;
-		    *out++ = (green << 24) | (red << 16) | (green << 8) | blue;
-		}
-	    }
-
-	    /* Images here are stored in native format. The
-	     * backend must convert to its own format as needed
-	     */
-
-	    if (own_buffer)
-		free (bitmap->buffer);
-	    data = data_rgba;
-	    stride = stride_rgba;
 	    format = CAIRO_FORMAT_ARGB32;
-	    subpixel = TRUE;
-	    break;
-	}
 	}
 	break;
     case FT_PIXEL_MODE_GRAY2:
@@ -948,19 +1143,20 @@
 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     }
 
-    *surface = (cairo_image_surface_t *)
+    /* XXX */
+    *surface = image = (cairo_image_surface_t *)
 	cairo_image_surface_create_for_data (data,
 					     format,
 					     width, height, stride);
-    if ((*surface)->base.status) {
+    if (image->base.status) {
 	free (data);
 	return (*surface)->base.status;
     }
 
-    if (subpixel)
-	pixman_image_set_component_alpha ((*surface)->pixman_image, TRUE);
+    if (font_options->antialias == CAIRO_ANTIALIAS_SUBPIXEL)
+	pixman_image_set_component_alpha (image->pixman_image, TRUE);
 
-    _cairo_image_surface_assume_ownership_of_data ((*surface));
+    _cairo_image_surface_assume_ownership_of_data (image);
 
     return CAIRO_STATUS_SUCCESS;
 }
@@ -985,16 +1181,59 @@
 		       cairo_font_options_t	 *font_options,
 		       cairo_image_surface_t	**surface)
 {
+    int rgba = FC_RGBA_UNKNOWN;
+    int lcd_filter = FT_LCD_FILTER_LEGACY;
     FT_GlyphSlot glyphslot = face->glyph;
     FT_Outline *outline = &glyphslot->outline;
     FT_Bitmap bitmap;
     FT_BBox cbox;
-    FT_Matrix matrix;
-    int hmul = 1;
-    int vmul = 1;
-    unsigned int width, height, stride;
-    cairo_bool_t subpixel = FALSE;
+    unsigned int width, height;
     cairo_status_t status;
+    FT_Error fterror;
+    FT_Library library = glyphslot->library;
+    FT_Render_Mode render_mode = FT_RENDER_MODE_NORMAL;
+
+    switch (font_options->antialias) {
+    case CAIRO_ANTIALIAS_NONE:
+	render_mode = FT_RENDER_MODE_MONO;
+	break;
+
+    case CAIRO_ANTIALIAS_SUBPIXEL:
+	switch (font_options->subpixel_order) {
+	    case CAIRO_SUBPIXEL_ORDER_DEFAULT:
+	    case CAIRO_SUBPIXEL_ORDER_RGB:
+	    case CAIRO_SUBPIXEL_ORDER_BGR:
+		render_mode = FT_RENDER_MODE_LCD;
+		break;
+
+	    case CAIRO_SUBPIXEL_ORDER_VRGB:
+	    case CAIRO_SUBPIXEL_ORDER_VBGR:
+		render_mode = FT_RENDER_MODE_LCD_V;
+		break;
+	}
+
+	switch (font_options->lcd_filter) {
+	case CAIRO_LCD_FILTER_NONE:
+	    lcd_filter = FT_LCD_FILTER_NONE;
+	    break;
+	case CAIRO_LCD_FILTER_DEFAULT:
+	case CAIRO_LCD_FILTER_INTRA_PIXEL:
+	    lcd_filter = FT_LCD_FILTER_LEGACY;
+	    break;
+	case CAIRO_LCD_FILTER_FIR3:
+	    lcd_filter = FT_LCD_FILTER_LIGHT;
+	    break;
+	case CAIRO_LCD_FILTER_FIR5:
+	    lcd_filter = FT_LCD_FILTER_DEFAULT;
+	    break;
+	}
+
+	break;
+
+    case CAIRO_ANTIALIAS_DEFAULT:
+    case CAIRO_ANTIALIAS_GRAY:
+	render_mode = FT_RENDER_MODE_NORMAL;
+    }
 
     FT_Outline_Get_CBox (outline, &cbox);
 
@@ -1005,20 +1244,21 @@
 
     width = (unsigned int) ((cbox.xMax - cbox.xMin) >> 6);
     height = (unsigned int) ((cbox.yMax - cbox.yMin) >> 6);
-    stride = (width * hmul + 3) & ~3;
 
     if (width * height == 0) {
 	cairo_format_t format;
 	/* Looks like fb handles zero-sized images just fine */
-	switch (font_options->antialias) {
-	case CAIRO_ANTIALIAS_NONE:
+	switch (render_mode) {
+	case FT_RENDER_MODE_MONO:
 	    format = CAIRO_FORMAT_A1;
 	    break;
-	case CAIRO_ANTIALIAS_SUBPIXEL:
+	case FT_RENDER_MODE_LCD:
+	case FT_RENDER_MODE_LCD_V:
 	    format= CAIRO_FORMAT_ARGB32;
 	    break;
-	case CAIRO_ANTIALIAS_DEFAULT:
-	case CAIRO_ANTIALIAS_GRAY:
+	case FT_RENDER_MODE_LIGHT:
+	case FT_RENDER_MODE_NORMAL:
+	case FT_RENDER_MODE_MAX:
 	default:
 	    format = CAIRO_FORMAT_A8;
 	    break;
@@ -1030,73 +1270,73 @@
 	    return (*surface)->base.status;
     } else  {
 
-	matrix.xx = matrix.yy = 0x10000L;
-	matrix.xy = matrix.yx = 0;
+	int bitmap_size;
 
-	switch (font_options->antialias) {
-	case CAIRO_ANTIALIAS_NONE:
-	    bitmap.pixel_mode = FT_PIXEL_MODE_MONO;
-	    bitmap.num_grays  = 1;
-	    stride = ((width + 31) & -32) >> 3;
-	    break;
-	case CAIRO_ANTIALIAS_DEFAULT:
-	case CAIRO_ANTIALIAS_GRAY:
-	    bitmap.pixel_mode = FT_PIXEL_MODE_GRAY;
-	    bitmap.num_grays  = 256;
-	    stride = (width + 3) & -4;
+	switch (render_mode) {
+	case FT_RENDER_MODE_LCD:
+	    if (font_options->subpixel_order == CAIRO_SUBPIXEL_ORDER_BGR) {
+		rgba = FC_RGBA_BGR;
+	    } else {
+		rgba = FC_RGBA_RGB;
+	    }
 	    break;
-	case CAIRO_ANTIALIAS_SUBPIXEL:
-	    switch (font_options->subpixel_order) {
-	    case CAIRO_SUBPIXEL_ORDER_RGB:
-	    case CAIRO_SUBPIXEL_ORDER_BGR:
-	    case CAIRO_SUBPIXEL_ORDER_DEFAULT:
-	    default:
-		matrix.xx *= 3;
-		hmul = 3;
-		subpixel = TRUE;
-		break;
-	    case CAIRO_SUBPIXEL_ORDER_VRGB:
-	    case CAIRO_SUBPIXEL_ORDER_VBGR:
-		matrix.yy *= 3;
-		vmul = 3;
-		subpixel = TRUE;
-		break;
+	case FT_RENDER_MODE_LCD_V:
+	    if (font_options->subpixel_order == CAIRO_SUBPIXEL_ORDER_VBGR) {
+		rgba = FC_RGBA_VBGR;
+	    } else {
+		rgba = FC_RGBA_VRGB;
 	    }
-	    FT_Outline_Transform (outline, &matrix);
-
-	    bitmap.pixel_mode = FT_PIXEL_MODE_GRAY;
-	    bitmap.num_grays  = 256;
-	    stride = (width * hmul + 3) & -4;
+	    break;
+	case FT_RENDER_MODE_MONO:
+	case FT_RENDER_MODE_LIGHT:
+	case FT_RENDER_MODE_NORMAL:
+	case FT_RENDER_MODE_MAX:
+	default:
+	    break;
 	}
 
-	bitmap.pitch = stride;
-	bitmap.width = width * hmul;
-	bitmap.rows = height * vmul;
-	bitmap.buffer = calloc (stride, bitmap.rows);
-	if (bitmap.buffer == NULL)
+#if HAVE_FT_LIBRARY_SETLCDFILTER
+	FT_Library_SetLcdFilter (library, lcd_filter);
+#endif
+
+	fterror = FT_Render_Glyph (face->glyph, render_mode);
+
+#if HAVE_FT_LIBRARY_SETLCDFILTER
+	FT_Library_SetLcdFilter (library, FT_LCD_FILTER_NONE);
+#endif
+
+	if (fterror != 0)
 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
-	FT_Outline_Translate (outline, -cbox.xMin*hmul, -cbox.yMin*vmul);
+	bitmap_size = _compute_xrender_bitmap_size (&bitmap,
+						    face->glyph,
+						    render_mode);
+	if (bitmap_size < 0)
+	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
-	if (FT_Outline_Get_Bitmap (glyphslot->library, outline, &bitmap) != 0) {
-	    free (bitmap.buffer);
+	bitmap.buffer = calloc (1, bitmap_size);
+	if (bitmap.buffer == NULL)
 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
-	}
 
+	_fill_xrender_bitmap (&bitmap, face->glyph, render_mode,
+			      (rgba == FC_RGBA_BGR || rgba == FC_RGBA_VBGR));
+
+	/* Note:
+	 * _get_bitmap_surface will free bitmap.buffer if there is an error
+	 */
 	status = _get_bitmap_surface (&bitmap, TRUE, font_options, surface);
 	if (status)
 	    return status;
-    }
 
-    /*
-     * Note: the font's coordinate system is upside down from ours, so the
-     * Y coordinate of the control box needs to be negated.  Moreover, device
-     * offsets are position of glyph origin relative to top left while xMin
-     * and yMax are offsets of top left relative to origin.  Another negation.
-     */
-    cairo_surface_set_device_offset (&(*surface)->base,
-				     floor (-(double) cbox.xMin / 64.0),
-				     floor (+(double) cbox.yMax / 64.0));
+	/* Note: the font's coordinate system is upside down from ours, so the
+	 * Y coordinate of the control box needs to be negated.  Moreover, device
+	 * offsets are position of glyph origin relative to top left while xMin
+	 * and yMax are offsets of top left relative to origin.  Another negation.
+	 */
+	cairo_surface_set_device_offset (&(*surface)->base,
+					 (double)-glyphslot->bitmap_left,
+					 (double)+glyphslot->bitmap_top);
+    }
 
     return CAIRO_STATUS_SUCCESS;
 }
@@ -1316,6 +1556,7 @@
     
     if (antialias) {
 	cairo_subpixel_order_t subpixel_order;
+	int lcd_filter;
 
 	/* disable hinting if requested */
 	if (FcPatternGetBool (pattern,
@@ -1351,6 +1592,25 @@
 	    ft_options.base.antialias = CAIRO_ANTIALIAS_SUBPIXEL;
 	}
 
+	if (FcPatternGetInteger (pattern,
+				 FC_LCD_FILTER, 0, &lcd_filter) == FcResultMatch)
+	{
+	    switch (lcd_filter) {
+	    case FC_LCD_NONE:
+		ft_options.base.lcd_filter = CAIRO_LCD_FILTER_NONE;
+		break;
+	    case FC_LCD_DEFAULT:
+		ft_options.base.lcd_filter = CAIRO_LCD_FILTER_FIR5;
+		break;
+	    case FC_LCD_LIGHT:
+		ft_options.base.lcd_filter = CAIRO_LCD_FILTER_FIR3;
+		break;
+	    case FC_LCD_LEGACY:
+		ft_options.base.lcd_filter = CAIRO_LCD_FILTER_INTRA_PIXEL;
+		break;
+	    }
+	}
+
 #ifdef FC_HINT_STYLE    
 	if (FcPatternGetInteger (pattern, 
 				 FC_HINT_STYLE, 0, &hintstyle) != FcResultMatch)
@@ -1451,6 +1711,12 @@
     if (other->base.hint_style == CAIRO_HINT_STYLE_NONE)
 	options->base.hint_style = CAIRO_HINT_STYLE_NONE;
 
+    if (options->base.lcd_filter == CAIRO_LCD_FILTER_DEFAULT)
+	options->base.lcd_filter = other->base.lcd_filter;
+
+    if (other->base.lcd_filter == CAIRO_LCD_FILTER_NONE)
+	options->base.lcd_filter = CAIRO_LCD_FILTER_NONE;
+
     if (options->base.antialias == CAIRO_ANTIALIAS_NONE) {
 	if (options->base.hint_style == CAIRO_HINT_STYLE_NONE)
 	    load_flags |= FT_LOAD_NO_HINTING;
@@ -1474,11 +1740,11 @@
 		case CAIRO_SUBPIXEL_ORDER_DEFAULT:
 		case CAIRO_SUBPIXEL_ORDER_RGB:
 		case CAIRO_SUBPIXEL_ORDER_BGR:
-		    load_target |= FT_LOAD_TARGET_LCD;
+		    load_target = FT_LOAD_TARGET_LCD;
 		    break;
 		case CAIRO_SUBPIXEL_ORDER_VRGB:
 		case CAIRO_SUBPIXEL_ORDER_VBGR:
-		    load_target |= FT_LOAD_TARGET_LCD_V;
+		    load_target = FT_LOAD_TARGET_LCD_V;
 		break;
 		}
 	    }
@@ -2423,6 +2689,34 @@
 	}
     }
 
+    if (options->lcd_filter != CAIRO_LCD_FILTER_DEFAULT)
+    {
+	if (FcPatternGet (pattern, FC_LCD_FILTER, 0, &v) == FcResultNoMatch)
+	{
+	    int lcd_filter;
+
+	    switch (options->lcd_filter) {
+	    case CAIRO_LCD_FILTER_NONE:
+		lcd_filter = FT_LCD_FILTER_NONE;
+		break;
+	    case CAIRO_LCD_FILTER_DEFAULT:
+	    case CAIRO_LCD_FILTER_INTRA_PIXEL:
+		lcd_filter = FT_LCD_FILTER_LEGACY;
+		break;
+	    case CAIRO_LCD_FILTER_FIR3:
+		lcd_filter = FT_LCD_FILTER_LIGHT;
+		break;
+	    default:
+	    case CAIRO_LCD_FILTER_FIR5:
+		lcd_filter = FT_LCD_FILTER_DEFAULT;
+		break;
+	    }
+
+	    if (! FcPatternAddInteger (pattern, FC_LCD_FILTER, lcd_filter))
+		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	}
+    }
+
     if (options->hint_style != CAIRO_HINT_STYLE_DEFAULT)
     {
 	if (FcPatternGet (pattern, FC_HINTING, 0, &v) == FcResultNoMatch)
diff -Naur cairo-1.8.4-debian-1/src/cairo-ft-font.c.orig cairo-1.8.4-debian-2/src/cairo-ft-font.c.orig
--- cairo-1.8.4-debian-1/src/cairo-ft-font.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ cairo-1.8.4-debian-2/src/cairo-ft-font.c.orig	2008-12-04 19:47:17.000000000 +0100
@@ -0,0 +1,2746 @@
+/* -*- Mode: c; c-basic-offset: 4; indent-tabs-mode: t; tab-width: 8; -*- */
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2000 Keith Packard
+ * Copyright © 2005 Red Hat, Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Red Hat, Inc.
+ *
+ * Contributor(s):
+ *      Graydon Hoare <graydon@redhat.com>
+ *	Owen Taylor <otaylor@redhat.com>
+ *      Keith Packard <keithp@keithp.com>
+ *      Carl Worth <cworth@cworth.org>
+ */
+
+#define _BSD_SOURCE /* for strdup() */
+#include "cairoint.h"
+
+#include "cairo-ft-private.h"
+
+#include <float.h>
+
+#include <fontconfig/fontconfig.h>
+#include <fontconfig/fcfreetype.h>
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_OUTLINE_H
+#include FT_IMAGE_H
+#include FT_TRUETYPE_TABLES_H
+#if HAVE_FT_GLYPHSLOT_EMBOLDEN
+#include FT_SYNTHESIS_H
+#endif
+
+#define DOUBLE_TO_26_6(d) ((FT_F26Dot6)((d) * 64.0))
+#define DOUBLE_FROM_26_6(t) ((double)(t) / 64.0)
+#define DOUBLE_TO_16_16(d) ((FT_Fixed)((d) * 65536.0))
+#define DOUBLE_FROM_16_16(t) ((double)(t) / 65536.0)
+
+/* This is the max number of FT_face objects we keep open at once
+ */
+#define MAX_OPEN_FACES 10
+
+/*
+ * The simple 2x2 matrix is converted into separate scale and shape
+ * factors so that hinting works right
+ */
+
+typedef struct _cairo_ft_font_transform {
+    double  x_scale, y_scale;
+    double  shape[2][2];
+} cairo_ft_font_transform_t;
+
+/*
+ * We create an object that corresponds to a single font on the disk;
+ * (identified by a filename/id pair) these are shared between all
+ * fonts using that file.  For cairo_ft_font_face_create_for_ft_face(), we
+ * just create a one-off version with a permanent face value.
+ */
+
+typedef struct _cairo_ft_font_face cairo_ft_font_face_t;
+
+struct _cairo_ft_unscaled_font {
+    cairo_unscaled_font_t base;
+
+    cairo_bool_t from_face; /* was the FT_Face provided by user? */
+    FT_Face face;	    /* provided or cached face */
+
+    /* only set if from_face is false */
+    char *filename;
+    int id;
+
+    /* We temporarily scale the unscaled font as needed */
+    cairo_bool_t have_scale;
+    cairo_matrix_t current_scale;
+    double x_scale;		/* Extracted X scale factor */
+    double y_scale;             /* Extracted Y scale factor */
+    cairo_bool_t have_shape;	/* true if the current scale has a non-scale component*/
+    cairo_matrix_t current_shape;
+    FT_Matrix Current_Shape;
+
+    cairo_mutex_t mutex;
+    int lock_count;
+
+    cairo_ft_font_face_t *faces;	/* Linked list of faces for this font */
+};
+
+static int
+_cairo_ft_unscaled_font_keys_equal (const void *key_a,
+				    const void *key_b);
+
+static void
+_cairo_ft_unscaled_font_fini (cairo_ft_unscaled_font_t *unscaled);
+
+static cairo_status_t
+_cairo_ft_font_options_substitute (const cairo_font_options_t *options,
+				   FcPattern                  *pattern);
+
+typedef enum _cairo_ft_extra_flags {
+    CAIRO_FT_OPTIONS_HINT_METRICS = (1 << 0),
+    CAIRO_FT_OPTIONS_EMBOLDEN = (1 << 1)
+} cairo_ft_extra_flags_t;
+
+typedef struct _cairo_ft_options {
+    cairo_font_options_t    base;
+    int			    load_flags;	 /* flags for FT_Load_Glyph */
+    cairo_ft_extra_flags_t  extra_flags; /* other flags that affect results */
+} cairo_ft_options_t;
+
+struct _cairo_ft_font_face {
+    cairo_font_face_t base;
+    cairo_ft_unscaled_font_t *unscaled;
+    cairo_ft_options_t ft_options;
+    cairo_ft_font_face_t *next;
+};
+
+static const cairo_unscaled_font_backend_t cairo_ft_unscaled_font_backend;
+
+/*
+ * We maintain a hash table to map file/id => #cairo_ft_unscaled_font_t.
+ * The hash table itself isn't limited in size. However, we limit the
+ * number of FT_Face objects we keep around; when we've exceeded that
+ * limit and need to create a new FT_Face, we dump the FT_Face from a
+ * random #cairo_ft_unscaled_font_t which has an unlocked FT_Face, (if
+ * there are any).
+ */
+
+typedef struct _cairo_ft_unscaled_font_map {
+    cairo_hash_table_t *hash_table;
+    FT_Library ft_library;
+    int num_open_faces;
+} cairo_ft_unscaled_font_map_t;
+
+static cairo_ft_unscaled_font_map_t *cairo_ft_unscaled_font_map = NULL;
+
+static void
+_font_map_release_face_lock_held (cairo_ft_unscaled_font_map_t *font_map,
+				  cairo_ft_unscaled_font_t *unscaled)
+{
+    if (unscaled->face) {
+	FT_Done_Face (unscaled->face);
+	unscaled->face = NULL;
+	unscaled->have_scale = FALSE;
+
+	font_map->num_open_faces--;
+    }
+}
+
+static void
+_cairo_ft_unscaled_font_map_create (void)
+{
+    cairo_ft_unscaled_font_map_t *font_map;
+
+    /* This function is only intended to be called from
+     * _cairo_ft_unscaled_font_map_lock. So we'll crash if we can
+     * detect some other call path. */
+    assert (cairo_ft_unscaled_font_map == NULL);
+
+    font_map = malloc (sizeof (cairo_ft_unscaled_font_map_t));
+    if (font_map == NULL) {
+	_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
+	goto FAIL;
+    }
+
+    font_map->hash_table =
+	_cairo_hash_table_create (_cairo_ft_unscaled_font_keys_equal);
+
+    if (font_map->hash_table == NULL)
+	goto FAIL;
+
+    if (FT_Init_FreeType (&font_map->ft_library))
+	goto FAIL;
+
+    font_map->num_open_faces = 0;
+
+    cairo_ft_unscaled_font_map = font_map;
+    return;
+
+FAIL:
+    if (font_map) {
+	if (font_map->hash_table)
+	    _cairo_hash_table_destroy (font_map->hash_table);
+	free (font_map);
+    }
+    cairo_ft_unscaled_font_map = NULL;
+}
+
+static void
+_cairo_ft_unscaled_font_map_destroy (void)
+{
+    cairo_ft_unscaled_font_t *unscaled;
+    cairo_ft_unscaled_font_map_t *font_map;
+
+    CAIRO_MUTEX_LOCK (_cairo_ft_unscaled_font_map_mutex);
+
+    if (cairo_ft_unscaled_font_map) {
+	font_map = cairo_ft_unscaled_font_map;
+
+	/* This is rather inefficient, but destroying the hash table
+	 * is something we only do during debugging, (during
+	 * cairo_debug_reset_static_data), when efficiency is not
+	 * relevant. */
+        while (1) {
+	    unscaled = _cairo_hash_table_random_entry (font_map->hash_table,
+						       NULL);
+	    if (unscaled == NULL)
+		break;
+	    _cairo_hash_table_remove (font_map->hash_table,
+				      &unscaled->base.hash_entry);
+
+	    _font_map_release_face_lock_held (font_map, unscaled);
+	    _cairo_ft_unscaled_font_fini (unscaled);
+	    free (unscaled);
+	}
+
+	assert (font_map->num_open_faces == 0);
+
+	FT_Done_FreeType (font_map->ft_library);
+
+	_cairo_hash_table_destroy (font_map->hash_table);
+
+	free (font_map);
+
+	cairo_ft_unscaled_font_map = NULL;
+    }
+
+    CAIRO_MUTEX_UNLOCK (_cairo_ft_unscaled_font_map_mutex);
+}
+
+static cairo_ft_unscaled_font_map_t *
+_cairo_ft_unscaled_font_map_lock (void)
+{
+    CAIRO_MUTEX_LOCK (_cairo_ft_unscaled_font_map_mutex);
+
+    if (cairo_ft_unscaled_font_map == NULL)
+    {
+	_cairo_ft_unscaled_font_map_create ();
+
+	if (cairo_ft_unscaled_font_map == NULL) {
+	    CAIRO_MUTEX_UNLOCK (_cairo_ft_unscaled_font_map_mutex);
+	    _cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
+	    return NULL;
+	}
+    }
+
+    return cairo_ft_unscaled_font_map;
+}
+
+static void
+_cairo_ft_unscaled_font_map_unlock (void)
+{
+    CAIRO_MUTEX_UNLOCK (_cairo_ft_unscaled_font_map_mutex);
+}
+
+static void
+_cairo_ft_unscaled_font_init_key (cairo_ft_unscaled_font_t *key,
+				  cairo_bool_t              from_face,
+				  char			   *filename,
+				  int			    id,
+				  FT_Face		    face)
+{
+    unsigned long hash;
+
+    key->from_face = from_face;
+    key->filename = filename;
+    key->id = id;
+    key->face = face;
+
+    hash = _cairo_hash_string (filename);
+    /* the constants are just arbitrary primes */
+    hash += ((unsigned long) id) * 1607;
+    hash += ((unsigned long) face) * 2137;
+
+    key->base.hash_entry.hash = hash;
+}
+
+/**
+ * _cairo_ft_unscaled_font_init:
+ *
+ * Initialize a #cairo_ft_unscaled_font_t.
+ *
+ * There are two basic flavors of #cairo_ft_unscaled_font_t, one
+ * created from an FT_Face and the other created from a filename/id
+ * pair. These two flavors are identified as from_face and !from_face.
+ *
+ * To initialize a from_face font, pass filename==%NULL, id=0 and the
+ * desired face.
+ *
+ * To initialize a !from_face font, pass the filename/id as desired
+ * and face==%NULL.
+ *
+ * Note that the code handles these two flavors in very distinct
+ * ways. For example there is a hash_table mapping
+ * filename/id->#cairo_unscaled_font_t in the !from_face case, but no
+ * parallel in the from_face case, (where the calling code would have
+ * to do its own mapping to ensure similar sharing).
+ **/
+static cairo_status_t
+_cairo_ft_unscaled_font_init (cairo_ft_unscaled_font_t *unscaled,
+			      cairo_bool_t              from_face,
+			      const char	       *filename,
+			      int			id,
+			      FT_Face			face)
+{
+    _cairo_unscaled_font_init (&unscaled->base,
+			       &cairo_ft_unscaled_font_backend);
+
+    if (from_face) {
+	unscaled->from_face = TRUE;
+	_cairo_ft_unscaled_font_init_key (unscaled, TRUE, NULL, 0, face);
+    } else {
+	char *filename_copy;
+
+	unscaled->from_face = FALSE;
+	unscaled->face = NULL;
+
+	filename_copy = strdup (filename);
+	if (filename_copy == NULL)
+	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	_cairo_ft_unscaled_font_init_key (unscaled, FALSE, filename_copy, id, NULL);
+    }
+
+    unscaled->have_scale = FALSE;
+    CAIRO_MUTEX_INIT (unscaled->mutex);
+    unscaled->lock_count = 0;
+
+    unscaled->faces = NULL;
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+/**
+ * _cairo_ft_unscaled_font_fini:
+ *
+ * Free all data associated with a #cairo_ft_unscaled_font_t.
+ *
+ * CAUTION: The unscaled->face field must be %NULL before calling this
+ * function. This is because the #cairo_ft_unscaled_font_t_map keeps a
+ * count of these faces (font_map->num_open_faces) so it maintains the
+ * unscaled->face field while it has its lock held. See
+ * _font_map_release_face_lock_held().
+ **/
+static void
+_cairo_ft_unscaled_font_fini (cairo_ft_unscaled_font_t *unscaled)
+{
+    assert (unscaled->face == NULL);
+
+    if (unscaled->filename) {
+	free (unscaled->filename);
+	unscaled->filename = NULL;
+    }
+
+    CAIRO_MUTEX_FINI (unscaled->mutex);
+}
+
+static int
+_cairo_ft_unscaled_font_keys_equal (const void *key_a,
+				    const void *key_b)
+{
+    const cairo_ft_unscaled_font_t *unscaled_a = key_a;
+    const cairo_ft_unscaled_font_t *unscaled_b = key_b;
+
+    if (unscaled_a->id == unscaled_b->id &&
+	unscaled_a->from_face == unscaled_b->from_face)
+    {
+        if (unscaled_a->from_face)
+	    return unscaled_a->face == unscaled_b->face;
+
+	if (unscaled_a->filename == NULL && unscaled_b->filename == NULL)
+	    return TRUE;
+	else if (unscaled_a->filename == NULL || unscaled_b->filename == NULL)
+	    return FALSE;
+	else
+	    return (strcmp (unscaled_a->filename, unscaled_b->filename) == 0);
+    }
+
+    return FALSE;
+}
+
+/* Finds or creates a #cairo_ft_unscaled_font_t for the filename/id from
+ * pattern.  Returns a new reference to the unscaled font.
+ */
+static cairo_ft_unscaled_font_t *
+_cairo_ft_unscaled_font_create_internal (cairo_bool_t from_face,
+					 char *filename,
+					 int id,
+					 FT_Face font_face)
+{
+    cairo_ft_unscaled_font_t key, *unscaled;
+    cairo_ft_unscaled_font_map_t *font_map;
+    cairo_status_t status;
+
+    font_map = _cairo_ft_unscaled_font_map_lock ();
+    if (font_map == NULL)
+	goto UNWIND;
+
+    _cairo_ft_unscaled_font_init_key (&key, from_face, filename, id, font_face);
+
+    /* Return existing unscaled font if it exists in the hash table. */
+    if (_cairo_hash_table_lookup (font_map->hash_table, &key.base.hash_entry,
+				  (cairo_hash_entry_t **) &unscaled))
+    {
+	_cairo_unscaled_font_reference (&unscaled->base);
+	_cairo_ft_unscaled_font_map_unlock ();
+	return unscaled;
+    }
+
+    /* Otherwise create it and insert into hash table. */
+    unscaled = malloc (sizeof (cairo_ft_unscaled_font_t));
+    if (unscaled == NULL) {
+	_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
+	goto UNWIND_FONT_MAP_LOCK;
+    }
+
+    status = _cairo_ft_unscaled_font_init (unscaled, from_face, filename, id, font_face);
+    if (status)
+	goto UNWIND_UNSCALED_MALLOC;
+
+    status = _cairo_hash_table_insert (font_map->hash_table,
+				       &unscaled->base.hash_entry);
+    if (status)
+	goto UNWIND_UNSCALED_FONT_INIT;
+
+    _cairo_ft_unscaled_font_map_unlock ();
+
+    return unscaled;
+
+UNWIND_UNSCALED_FONT_INIT:
+    _cairo_ft_unscaled_font_fini (unscaled);
+UNWIND_UNSCALED_MALLOC:
+    free (unscaled);
+UNWIND_FONT_MAP_LOCK:
+    _cairo_ft_unscaled_font_map_unlock ();
+UNWIND:
+    return NULL;
+}
+
+
+static cairo_ft_unscaled_font_t *
+_cairo_ft_unscaled_font_create_for_pattern (FcPattern *pattern)
+{
+    FT_Face font_face = NULL;
+    char *filename = NULL;
+    int id = 0;
+
+    if (FcPatternGetFTFace (pattern, FC_FT_FACE, 0, &font_face) != FcResultMatch) {
+	FcChar8 *fc_filename = NULL;
+
+	if (FcPatternGetString (pattern, FC_FILE, 0, &fc_filename) != FcResultMatch)
+	    goto UNWIND;
+	filename = (char *) fc_filename;
+
+	if (FcPatternGetInteger (pattern, FC_INDEX, 0, &id) != FcResultMatch)
+	    goto UNWIND;
+    }
+
+    return _cairo_ft_unscaled_font_create_internal (font_face != NULL, filename, id, font_face);
+
+UNWIND:
+    return NULL;
+}
+
+static cairo_ft_unscaled_font_t *
+_cairo_ft_unscaled_font_create_from_face (FT_Face face)
+{
+    return _cairo_ft_unscaled_font_create_internal (TRUE, NULL, 0, face);
+}
+
+static void
+_cairo_ft_unscaled_font_destroy (void *abstract_font)
+{
+    cairo_ft_unscaled_font_t *unscaled  = abstract_font;
+    cairo_ft_unscaled_font_map_t *font_map;
+
+    if (unscaled == NULL)
+	return;
+
+    font_map = _cairo_ft_unscaled_font_map_lock ();
+    /* All created objects must have been mapped in the font map. */
+    assert (font_map != NULL);
+
+    _cairo_hash_table_remove (font_map->hash_table,
+			      &unscaled->base.hash_entry);
+
+    if (unscaled->from_face) {
+	/* See comments in _ft_font_face_destroy about the "zombie" state
+	 * for a _ft_font_face.
+	 */
+	if (unscaled->faces && !unscaled->faces->unscaled)
+	    cairo_font_face_destroy (&unscaled->faces->base);
+    } else {
+	_font_map_release_face_lock_held (font_map, unscaled);
+    }
+    unscaled->face = NULL;
+
+    _cairo_ft_unscaled_font_map_unlock ();
+
+    _cairo_ft_unscaled_font_fini (unscaled);
+}
+
+static cairo_bool_t
+_has_unlocked_face (void *entry)
+{
+    cairo_ft_unscaled_font_t *unscaled = entry;
+
+    return (unscaled->lock_count == 0 && unscaled->face);
+}
+
+/* Ensures that an unscaled font has a face object. If we exceed
+ * MAX_OPEN_FACES, try to close some.
+ *
+ * This differs from _cairo_ft_scaled_font_lock_face in that it doesn't
+ * set the scale on the face, but just returns it at the last scale.
+ */
+cairo_warn FT_Face
+_cairo_ft_unscaled_font_lock_face (cairo_ft_unscaled_font_t *unscaled)
+{
+    cairo_ft_unscaled_font_map_t *font_map;
+    FT_Face face = NULL;
+
+    CAIRO_MUTEX_LOCK (unscaled->mutex);
+    unscaled->lock_count++;
+
+    if (unscaled->face)
+	return unscaled->face;
+
+    /* If this unscaled font was created from an FT_Face then we just
+     * returned it above. */
+    assert (!unscaled->from_face);
+
+    font_map = _cairo_ft_unscaled_font_map_lock ();
+    {
+	assert (font_map != NULL);
+
+	while (font_map->num_open_faces >= MAX_OPEN_FACES)
+	{
+	    cairo_ft_unscaled_font_t *entry;
+
+	    entry = _cairo_hash_table_random_entry (font_map->hash_table,
+						    _has_unlocked_face);
+	    if (entry == NULL)
+		break;
+
+	    _font_map_release_face_lock_held (font_map, entry);
+	}
+    }
+    _cairo_ft_unscaled_font_map_unlock ();
+
+    if (FT_New_Face (font_map->ft_library,
+		     unscaled->filename,
+		     unscaled->id,
+		     &face) != FT_Err_Ok)
+    {
+	unscaled->lock_count--;
+	CAIRO_MUTEX_UNLOCK (unscaled->mutex);
+	_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
+	return NULL;
+    }
+
+    unscaled->face = face;
+
+    font_map->num_open_faces++;
+
+    return face;
+}
+
+
+/* Unlock unscaled font locked with _cairo_ft_unscaled_font_lock_face
+ */
+void
+_cairo_ft_unscaled_font_unlock_face (cairo_ft_unscaled_font_t *unscaled)
+{
+    assert (unscaled->lock_count > 0);
+
+    unscaled->lock_count--;
+
+    CAIRO_MUTEX_UNLOCK (unscaled->mutex);
+}
+
+
+static cairo_status_t
+_compute_transform (cairo_ft_font_transform_t *sf,
+		    cairo_matrix_t      *scale)
+{
+    cairo_status_t status;
+    double x_scale, y_scale;
+    cairo_matrix_t normalized = *scale;
+
+    /* The font matrix has x and y "scale" components which we extract and
+     * use as character scale values. These influence the way freetype
+     * chooses hints, as well as selecting different bitmaps in
+     * hand-rendered fonts. We also copy the normalized matrix to
+     * freetype's transformation.
+     */
+
+    status = _cairo_matrix_compute_basis_scale_factors (scale,
+						  &x_scale, &y_scale,
+						  1);
+    if (status)
+	return status;
+
+    /* FreeType docs say this about x_scale and y_scale:
+     * "A character width or height smaller than 1pt is set to 1pt;"
+     * So, we cap them from below at 1.0 and let the FT transform
+     * take care of sub-1.0 scaling. */
+    if (x_scale < 1.0)
+      x_scale = 1.0;
+    if (y_scale < 1.0)
+      y_scale = 1.0;
+
+    sf->x_scale = x_scale;
+    sf->y_scale = y_scale;
+
+    cairo_matrix_scale (&normalized, 1.0 / x_scale, 1.0 / y_scale);
+
+    _cairo_matrix_get_affine (&normalized,
+			      &sf->shape[0][0], &sf->shape[0][1],
+			      &sf->shape[1][0], &sf->shape[1][1],
+			      NULL, NULL);
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+/* Temporarily scales an unscaled font to the give scale. We catch
+ * scaling to the same size, since changing a FT_Face is expensive.
+ */
+static cairo_status_t
+_cairo_ft_unscaled_font_set_scale (cairo_ft_unscaled_font_t *unscaled,
+				   cairo_matrix_t	      *scale)
+{
+    cairo_status_t status;
+    cairo_ft_font_transform_t sf;
+    FT_Matrix mat;
+    FT_Error error;
+
+    assert (unscaled->face != NULL);
+
+    if (unscaled->have_scale &&
+	scale->xx == unscaled->current_scale.xx &&
+	scale->yx == unscaled->current_scale.yx &&
+	scale->xy == unscaled->current_scale.xy &&
+	scale->yy == unscaled->current_scale.yy)
+	return CAIRO_STATUS_SUCCESS;
+
+    unscaled->have_scale = TRUE;
+    unscaled->current_scale = *scale;
+
+    status = _compute_transform (&sf, scale);
+    if (status)
+	return status;
+
+    unscaled->x_scale = sf.x_scale;
+    unscaled->y_scale = sf.y_scale;
+
+    mat.xx = DOUBLE_TO_16_16(sf.shape[0][0]);
+    mat.yx = - DOUBLE_TO_16_16(sf.shape[0][1]);
+    mat.xy = - DOUBLE_TO_16_16(sf.shape[1][0]);
+    mat.yy = DOUBLE_TO_16_16(sf.shape[1][1]);
+
+    unscaled->have_shape = (mat.xx != 0x10000 ||
+			    mat.yx != 0x00000 ||
+			    mat.xy != 0x00000 ||
+			    mat.yy != 0x10000);
+
+    unscaled->Current_Shape = mat;
+    cairo_matrix_init (&unscaled->current_shape,
+		       sf.shape[0][0], sf.shape[0][1],
+		       sf.shape[1][0], sf.shape[1][1],
+		       0.0, 0.0);
+
+    FT_Set_Transform(unscaled->face, &mat, NULL);
+
+    if ((unscaled->face->face_flags & FT_FACE_FLAG_SCALABLE) != 0) {
+	error = FT_Set_Char_Size (unscaled->face,
+				  sf.x_scale * 64.0 + .5,
+				  sf.y_scale * 64.0 + .5,
+				  0, 0);
+	if (error)
+	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    } else {
+	double min_distance = DBL_MAX;
+	int i;
+	int best_i = 0;
+
+	for (i = 0; i < unscaled->face->num_fixed_sizes; i++) {
+#if HAVE_FT_BITMAP_SIZE_Y_PPEM
+	    double size = unscaled->face->available_sizes[i].y_ppem / 64.;
+#else
+	    double size = unscaled->face->available_sizes[i].height;
+#endif
+	    double distance = fabs (size - sf.y_scale);
+
+	    if (distance <= min_distance) {
+		min_distance = distance;
+		best_i = i;
+	    }
+	}
+#if HAVE_FT_BITMAP_SIZE_Y_PPEM
+	error = FT_Set_Char_Size (unscaled->face,
+				  unscaled->face->available_sizes[best_i].x_ppem,
+				  unscaled->face->available_sizes[best_i].y_ppem,
+				  0, 0);
+	if (error)
+#endif
+	    error = FT_Set_Pixel_Sizes (unscaled->face,
+					unscaled->face->available_sizes[best_i].width,
+					unscaled->face->available_sizes[best_i].height);
+	if (error)
+	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    }
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+/* Empirically-derived subpixel filtering values thanks to Keith
+ * Packard and libXft. */
+static const int    filters[3][3] = {
+    /* red */
+#if 0
+    {    65538*4/7,65538*2/7,65538*1/7 },
+    /* green */
+    {    65536*1/4, 65536*2/4, 65537*1/4 },
+    /* blue */
+    {    65538*1/7,65538*2/7,65538*4/7 },
+#endif
+    {    65538*9/13,65538*3/13,65538*1/13 },
+    /* green */
+    {    65538*1/6, 65538*4/6, 65538*1/6 },
+    /* blue */
+    {    65538*1/13,65538*3/13,65538*9/13 },
+};
+
+/* Fills in val->image with an image surface created from @bitmap
+ */
+static cairo_status_t
+_get_bitmap_surface (FT_Bitmap		     *bitmap,
+		     cairo_bool_t	      own_buffer,
+		     cairo_font_options_t    *font_options,
+		     cairo_image_surface_t  **surface)
+{
+    int width, height, stride;
+    unsigned char *data;
+    int format = CAIRO_FORMAT_A8;
+    cairo_bool_t subpixel = FALSE;
+
+    width = bitmap->width;
+    height = bitmap->rows;
+
+    if (width == 0 || height == 0) {
+	*surface = (cairo_image_surface_t *)
+	    cairo_image_surface_create_for_data (NULL, format, 0, 0, 0);
+	return (*surface)->base.status;
+    }
+
+    switch (bitmap->pixel_mode) {
+    case FT_PIXEL_MODE_MONO:
+	stride = (((width + 31) & ~31) >> 3);
+	if (own_buffer) {
+	    data = bitmap->buffer;
+	    assert (stride == bitmap->pitch);
+	} else {
+	    data = _cairo_malloc_ab (height, stride);
+	    if (!data)
+		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+	    if (stride == bitmap->pitch) {
+		memcpy (data, bitmap->buffer, stride * height);
+	    } else {
+		int i;
+		unsigned char *source, *dest;
+
+		source = bitmap->buffer;
+		dest = data;
+		for (i = height; i; i--) {
+		    memcpy (dest, source, bitmap->pitch);
+		    memset (dest + bitmap->pitch, '\0', stride - bitmap->pitch);
+
+		    source += bitmap->pitch;
+		    dest += stride;
+		}
+	    }
+	}
+
+#ifndef WORDS_BIGENDIAN
+	{
+	    uint8_t   *d = data;
+	    int		count = stride * height;
+
+	    while (count--) {
+		*d = CAIRO_BITSWAP8 (*d);
+		d++;
+	    }
+	}
+#endif
+	format = CAIRO_FORMAT_A1;
+	break;
+
+    case FT_PIXEL_MODE_LCD:
+    case FT_PIXEL_MODE_LCD_V:
+    case FT_PIXEL_MODE_GRAY:
+	switch (font_options->antialias) {
+	case CAIRO_ANTIALIAS_DEFAULT:
+	case CAIRO_ANTIALIAS_GRAY:
+	case CAIRO_ANTIALIAS_NONE:
+	default:
+	    stride = bitmap->pitch;
+	    if (own_buffer) {
+		data = bitmap->buffer;
+	    } else {
+		data = _cairo_malloc_ab (height, stride);
+		if (!data)
+		    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+		memcpy (data, bitmap->buffer, stride * height);
+	    }
+	    format = CAIRO_FORMAT_A8;
+	    break;
+	case CAIRO_ANTIALIAS_SUBPIXEL: {
+	    int		    x, y;
+	    unsigned char   *in_line, *out_line, *in;
+	    unsigned int    *out;
+	    unsigned int    red, green, blue;
+	    int		    rf, gf, bf;
+	    int		    s;
+	    int		    o, os;
+	    unsigned char   *data_rgba;
+	    unsigned int    width_rgba, stride_rgba;
+	    int		    vmul = 1;
+	    int		    hmul = 1;
+
+	    switch (font_options->subpixel_order) {
+	    case CAIRO_SUBPIXEL_ORDER_DEFAULT:
+	    case CAIRO_SUBPIXEL_ORDER_RGB:
+	    case CAIRO_SUBPIXEL_ORDER_BGR:
+	    default:
+		width /= 3;
+		hmul = 3;
+		break;
+	    case CAIRO_SUBPIXEL_ORDER_VRGB:
+	    case CAIRO_SUBPIXEL_ORDER_VBGR:
+		vmul = 3;
+		height /= 3;
+		break;
+	    }
+	    /*
+	     * Filter the glyph to soften the color fringes
+	     */
+	    width_rgba = width;
+	    stride = bitmap->pitch;
+	    stride_rgba = (width_rgba * 4 + 3) & ~3;
+	    data_rgba = calloc (stride_rgba, height);
+	    if (data_rgba == NULL) {
+		if (own_buffer)
+		    free (bitmap->buffer);
+		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	    }
+
+	    os = 1;
+	    switch (font_options->subpixel_order) {
+	    case CAIRO_SUBPIXEL_ORDER_VRGB:
+		os = stride;
+	    case CAIRO_SUBPIXEL_ORDER_DEFAULT:
+	    case CAIRO_SUBPIXEL_ORDER_RGB:
+	    default:
+		rf = 0;
+		gf = 1;
+		bf = 2;
+		break;
+	    case CAIRO_SUBPIXEL_ORDER_VBGR:
+		os = stride;
+	    case CAIRO_SUBPIXEL_ORDER_BGR:
+		bf = 0;
+		gf = 1;
+		rf = 2;
+		break;
+	    }
+	    in_line = bitmap->buffer;
+	    out_line = data_rgba;
+	    for (y = 0; y < height; y++)
+	    {
+		in = in_line;
+		out = (unsigned int *) out_line;
+		in_line += stride * vmul;
+		out_line += stride_rgba;
+		for (x = 0; x < width * hmul; x += hmul)
+		{
+		    red = green = blue = 0;
+		    o = 0;
+		    for (s = 0; s < 3; s++)
+		    {
+			red += filters[rf][s]*in[x+o];
+			green += filters[gf][s]*in[x+o];
+			blue += filters[bf][s]*in[x+o];
+			o += os;
+		    }
+		    red = red / 65536;
+		    green = green / 65536;
+		    blue = blue / 65536;
+		    *out++ = (green << 24) | (red << 16) | (green << 8) | blue;
+		}
+	    }
+
+	    /* Images here are stored in native format. The
+	     * backend must convert to its own format as needed
+	     */
+
+	    if (own_buffer)
+		free (bitmap->buffer);
+	    data = data_rgba;
+	    stride = stride_rgba;
+	    format = CAIRO_FORMAT_ARGB32;
+	    subpixel = TRUE;
+	    break;
+	}
+	}
+	break;
+    case FT_PIXEL_MODE_GRAY2:
+    case FT_PIXEL_MODE_GRAY4:
+	/* These could be triggered by very rare types of TrueType fonts */
+    default:
+	if (own_buffer)
+	    free (bitmap->buffer);
+	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    }
+
+    *surface = (cairo_image_surface_t *)
+	cairo_image_surface_create_for_data (data,
+					     format,
+					     width, height, stride);
+    if ((*surface)->base.status) {
+	free (data);
+	return (*surface)->base.status;
+    }
+
+    if (subpixel)
+	pixman_image_set_component_alpha ((*surface)->pixman_image, TRUE);
+
+    _cairo_image_surface_assume_ownership_of_data ((*surface));
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+/* Converts an outline FT_GlyphSlot into an image
+ *
+ * This could go through _render_glyph_bitmap as well, letting
+ * FreeType convert the outline to a bitmap, but doing it ourselves
+ * has two minor advantages: first, we save a copy of the bitmap
+ * buffer: we can directly use the buffer that FreeType renders
+ * into.
+ *
+ * Second, it may help when we add support for subpixel
+ * rendering: the Xft code does it this way. (Keith thinks that
+ * it may also be possible to get the subpixel rendering with
+ * FT_Render_Glyph: something worth looking into in more detail
+ * when we add subpixel support. If so, we may want to eliminate
+ * this version of the code path entirely.
+ */
+static cairo_status_t
+_render_glyph_outline (FT_Face                    face,
+		       cairo_font_options_t	 *font_options,
+		       cairo_image_surface_t	**surface)
+{
+    FT_GlyphSlot glyphslot = face->glyph;
+    FT_Outline *outline = &glyphslot->outline;
+    FT_Bitmap bitmap;
+    FT_BBox cbox;
+    FT_Matrix matrix;
+    int hmul = 1;
+    int vmul = 1;
+    unsigned int width, height, stride;
+    cairo_bool_t subpixel = FALSE;
+    cairo_status_t status;
+
+    FT_Outline_Get_CBox (outline, &cbox);
+
+    cbox.xMin &= -64;
+    cbox.yMin &= -64;
+    cbox.xMax = (cbox.xMax + 63) & -64;
+    cbox.yMax = (cbox.yMax + 63) & -64;
+
+    width = (unsigned int) ((cbox.xMax - cbox.xMin) >> 6);
+    height = (unsigned int) ((cbox.yMax - cbox.yMin) >> 6);
+    stride = (width * hmul + 3) & ~3;
+
+    if (width * height == 0) {
+	cairo_format_t format;
+	/* Looks like fb handles zero-sized images just fine */
+	switch (font_options->antialias) {
+	case CAIRO_ANTIALIAS_NONE:
+	    format = CAIRO_FORMAT_A1;
+	    break;
+	case CAIRO_ANTIALIAS_SUBPIXEL:
+	    format= CAIRO_FORMAT_ARGB32;
+	    break;
+	case CAIRO_ANTIALIAS_DEFAULT:
+	case CAIRO_ANTIALIAS_GRAY:
+	default:
+	    format = CAIRO_FORMAT_A8;
+	    break;
+	}
+
+	(*surface) = (cairo_image_surface_t *)
+	    cairo_image_surface_create_for_data (NULL, format, 0, 0, 0);
+	if ((*surface)->base.status)
+	    return (*surface)->base.status;
+    } else  {
+
+	matrix.xx = matrix.yy = 0x10000L;
+	matrix.xy = matrix.yx = 0;
+
+	switch (font_options->antialias) {
+	case CAIRO_ANTIALIAS_NONE:
+	    bitmap.pixel_mode = FT_PIXEL_MODE_MONO;
+	    bitmap.num_grays  = 1;
+	    stride = ((width + 31) & -32) >> 3;
+	    break;
+	case CAIRO_ANTIALIAS_DEFAULT:
+	case CAIRO_ANTIALIAS_GRAY:
+	    bitmap.pixel_mode = FT_PIXEL_MODE_GRAY;
+	    bitmap.num_grays  = 256;
+	    stride = (width + 3) & -4;
+	    break;
+	case CAIRO_ANTIALIAS_SUBPIXEL:
+	    switch (font_options->subpixel_order) {
+	    case CAIRO_SUBPIXEL_ORDER_RGB:
+	    case CAIRO_SUBPIXEL_ORDER_BGR:
+	    case CAIRO_SUBPIXEL_ORDER_DEFAULT:
+	    default:
+		matrix.xx *= 3;
+		hmul = 3;
+		subpixel = TRUE;
+		break;
+	    case CAIRO_SUBPIXEL_ORDER_VRGB:
+	    case CAIRO_SUBPIXEL_ORDER_VBGR:
+		matrix.yy *= 3;
+		vmul = 3;
+		subpixel = TRUE;
+		break;
+	    }
+	    FT_Outline_Transform (outline, &matrix);
+
+	    bitmap.pixel_mode = FT_PIXEL_MODE_GRAY;
+	    bitmap.num_grays  = 256;
+	    stride = (width * hmul + 3) & -4;
+	}
+
+	bitmap.pitch = stride;
+	bitmap.width = width * hmul;
+	bitmap.rows = height * vmul;
+	bitmap.buffer = calloc (stride, bitmap.rows);
+	if (bitmap.buffer == NULL)
+	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+	FT_Outline_Translate (outline, -cbox.xMin*hmul, -cbox.yMin*vmul);
+
+	if (FT_Outline_Get_Bitmap (glyphslot->library, outline, &bitmap) != 0) {
+	    free (bitmap.buffer);
+	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	}
+
+	status = _get_bitmap_surface (&bitmap, TRUE, font_options, surface);
+	if (status)
+	    return status;
+    }
+
+    /*
+     * Note: the font's coordinate system is upside down from ours, so the
+     * Y coordinate of the control box needs to be negated.  Moreover, device
+     * offsets are position of glyph origin relative to top left while xMin
+     * and yMax are offsets of top left relative to origin.  Another negation.
+     */
+    cairo_surface_set_device_offset (&(*surface)->base,
+				     floor (-(double) cbox.xMin / 64.0),
+				     floor (+(double) cbox.yMax / 64.0));
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+/* Converts a bitmap (or other) FT_GlyphSlot into an image */
+static cairo_status_t
+_render_glyph_bitmap (FT_Face		      face,
+		      cairo_font_options_t   *font_options,
+		      cairo_image_surface_t **surface)
+{
+    FT_GlyphSlot glyphslot = face->glyph;
+    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    FT_Error error;
+
+    /* According to the FreeType docs, glyphslot->format could be
+     * something other than FT_GLYPH_FORMAT_OUTLINE or
+     * FT_GLYPH_FORMAT_BITMAP. Calling FT_Render_Glyph gives FreeType
+     * the opportunity to convert such to
+     * bitmap. FT_GLYPH_FORMAT_COMPOSITE will not be encountered since
+     * we avoid the FT_LOAD_NO_RECURSE flag.
+     */
+    error = FT_Render_Glyph (glyphslot, FT_RENDER_MODE_NORMAL);
+    /* XXX ignoring all other errors for now.  They are not fatal, typically
+     * just a glyph-not-found. */
+    if (error == FT_Err_Out_Of_Memory)
+	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+    status = _get_bitmap_surface (&glyphslot->bitmap, FALSE, font_options, surface);
+    if (status)
+	return status;
+
+    /*
+     * Note: the font's coordinate system is upside down from ours, so the
+     * Y coordinate of the control box needs to be negated.  Moreover, device
+     * offsets are position of glyph origin relative to top left while
+     * bitmap_left and bitmap_top are offsets of top left relative to origin.
+     * Another negation.
+     */
+    cairo_surface_set_device_offset (&(*surface)->base,
+				     -glyphslot->bitmap_left,
+				     +glyphslot->bitmap_top);
+
+    return status;
+}
+
+static cairo_status_t
+_transform_glyph_bitmap (cairo_matrix_t         * shape,
+			 cairo_image_surface_t ** surface)
+{
+    cairo_matrix_t original_to_transformed;
+    cairo_matrix_t transformed_to_original;
+    cairo_image_surface_t *old_image;
+    cairo_surface_t *image;
+    double x[4], y[4];
+    double origin_x, origin_y;
+    int orig_width, orig_height;
+    int i;
+    int x_min, y_min, x_max, y_max;
+    int width, height;
+    cairo_status_t status;
+    cairo_surface_pattern_t pattern;
+
+    /* We want to compute a transform that takes the origin
+     * (device_x_offset, device_y_offset) to 0,0, then applies
+     * the "shape" portion of the font transform
+     */
+    original_to_transformed = *shape;
+    
+    cairo_surface_get_device_offset (&(*surface)->base, &origin_x, &origin_y);
+    orig_width = cairo_image_surface_get_width (&(*surface)->base);
+    orig_height = cairo_image_surface_get_height (&(*surface)->base);
+
+    cairo_matrix_translate (&original_to_transformed,
+			    -origin_x, -origin_y);
+
+    /* Find the bounding box of the original bitmap under that
+     * transform
+     */
+    x[0] = 0;          y[0] = 0;
+    x[1] = orig_width; y[1] = 0;
+    x[2] = orig_width; y[2] = orig_height;
+    x[3] = 0;          y[3] = orig_height;
+
+    for (i = 0; i < 4; i++)
+      cairo_matrix_transform_point (&original_to_transformed,
+				    &x[i], &y[i]);
+
+    x_min = floor (x[0]);   y_min = floor (y[0]);
+    x_max =  ceil (x[0]);   y_max =  ceil (y[0]);
+
+    for (i = 1; i < 4; i++) {
+	if (x[i] < x_min)
+	    x_min = floor (x[i]);
+	else if (x[i] > x_max)
+	    x_max = ceil (x[i]);
+	if (y[i] < y_min)
+	    y_min = floor (y[i]);
+	else if (y[i] > y_max)
+	    y_max = ceil (y[i]);
+    }
+
+    /* Adjust the transform so that the bounding box starts at 0,0 ...
+     * this gives our final transform from original bitmap to transformed
+     * bitmap.
+     */
+    original_to_transformed.x0 -= x_min;
+    original_to_transformed.y0 -= y_min;
+
+    /* Create the transformed bitmap
+     */
+    width = x_max - x_min;
+    height = y_max - y_min;
+
+    transformed_to_original = original_to_transformed;
+    status = cairo_matrix_invert (&transformed_to_original);
+    if (status)
+	return status;
+
+    /* We need to pad out the width to 32-bit intervals for cairo-xlib-surface.c */
+    width = (width + 3) & ~3;
+    image = cairo_image_surface_create (CAIRO_FORMAT_A8, width, height);
+    if (image->status)
+	return image->status;
+
+    /* Initialize it to empty
+     */
+    status = _cairo_surface_fill_rectangle (image, CAIRO_OPERATOR_CLEAR,
+				            CAIRO_COLOR_TRANSPARENT,
+					    0, 0,
+					    width, height);
+    if (status) {
+	cairo_surface_destroy (image);
+	return status;
+    }
+
+    /* Draw the original bitmap transformed into the new bitmap
+     */
+    _cairo_pattern_init_for_surface (&pattern, &(*surface)->base);
+    cairo_pattern_set_matrix (&pattern.base, &transformed_to_original);
+
+    status = _cairo_surface_composite (CAIRO_OPERATOR_OVER,
+			               &pattern.base, NULL, image,
+				       0, 0, 0, 0, 0, 0,
+				       width,
+				       height);
+
+    _cairo_pattern_fini (&pattern.base);
+
+    if (status) {
+	cairo_surface_destroy (image);
+	return status;
+    }
+
+    /* Now update the cache entry for the new bitmap, recomputing
+     * the origin based on the final transform.
+     */
+    cairo_matrix_transform_point (&original_to_transformed,
+				  &origin_x, &origin_y);
+
+    old_image = (*surface);
+    (*surface) = (cairo_image_surface_t *)image;
+    cairo_surface_destroy (&old_image->base);
+
+    cairo_surface_set_device_offset (&(*surface)->base,
+				     _cairo_lround (origin_x),
+				     _cairo_lround (origin_y));
+    return status;
+}
+
+static const cairo_unscaled_font_backend_t cairo_ft_unscaled_font_backend = {
+    _cairo_ft_unscaled_font_destroy,
+#if 0
+    _cairo_ft_unscaled_font_create_glyph
+#endif
+};
+
+/* #cairo_ft_scaled_font_t */
+
+typedef struct _cairo_ft_scaled_font {
+    cairo_scaled_font_t base;
+    cairo_ft_unscaled_font_t *unscaled;
+    cairo_ft_options_t ft_options;
+} cairo_ft_scaled_font_t;
+
+const cairo_scaled_font_backend_t _cairo_ft_scaled_font_backend;
+
+/* The load flags passed to FT_Load_Glyph control aspects like hinting and
+ * antialiasing. Here we compute them from the fields of a FcPattern.
+ */
+static void
+_get_pattern_ft_options (FcPattern *pattern, cairo_ft_options_t *ret)
+{
+    FcBool antialias, vertical_layout, hinting, autohint, bitmap, embolden;
+    cairo_ft_options_t ft_options;
+    int rgba;
+#ifdef FC_HINT_STYLE
+    int hintstyle;
+#endif
+
+    _cairo_font_options_init_default (&ft_options.base);
+    ft_options.load_flags = FT_LOAD_DEFAULT;
+    ft_options.extra_flags = 0;
+
+#ifndef FC_EMBEDDED_BITMAP
+#define FC_EMBEDDED_BITMAP "embeddedbitmap"
+#endif
+
+    /* Check whether to force use of embedded bitmaps */
+    if (FcPatternGetBool (pattern,
+			  FC_EMBEDDED_BITMAP, 0, &bitmap) != FcResultMatch)
+	bitmap = FcFalse;
+
+    /* disable antialiasing if requested */
+    if (FcPatternGetBool (pattern,
+			  FC_ANTIALIAS, 0, &antialias) != FcResultMatch)
+	antialias = FcTrue;
+    
+    if (antialias) {
+	cairo_subpixel_order_t subpixel_order;
+
+	/* disable hinting if requested */
+	if (FcPatternGetBool (pattern,
+			      FC_HINTING, 0, &hinting) != FcResultMatch)
+	    hinting = FcTrue;
+
+	if (FcPatternGetInteger (pattern,
+				 FC_RGBA, 0, &rgba) != FcResultMatch)
+	    rgba = FC_RGBA_UNKNOWN;
+
+	switch (rgba) {
+	case FC_RGBA_RGB:
+	    subpixel_order = CAIRO_SUBPIXEL_ORDER_RGB;
+	    break;
+	case FC_RGBA_BGR:
+	    subpixel_order = CAIRO_SUBPIXEL_ORDER_BGR;
+	    break;
+	case FC_RGBA_VRGB:
+	    subpixel_order = CAIRO_SUBPIXEL_ORDER_VRGB;
+	    break;
+	case FC_RGBA_VBGR:
+	    subpixel_order = CAIRO_SUBPIXEL_ORDER_VBGR;
+	    break;
+	case FC_RGBA_UNKNOWN:
+	case FC_RGBA_NONE:
+	default:
+	    subpixel_order = CAIRO_SUBPIXEL_ORDER_DEFAULT;
+	    break;
+	}
+
+	if (subpixel_order != CAIRO_SUBPIXEL_ORDER_DEFAULT) {
+	    ft_options.base.subpixel_order = subpixel_order;
+	    ft_options.base.antialias = CAIRO_ANTIALIAS_SUBPIXEL;
+	}
+
+#ifdef FC_HINT_STYLE    
+	if (FcPatternGetInteger (pattern, 
+				 FC_HINT_STYLE, 0, &hintstyle) != FcResultMatch)
+	    hintstyle = FC_HINT_FULL;
+
+	if (!hinting)
+	    hintstyle = FC_HINT_NONE;
+
+	switch (hintstyle) {
+	case FC_HINT_NONE:
+	    ft_options.base.hint_style = CAIRO_HINT_STYLE_NONE;	
+	    break;
+	case FC_HINT_SLIGHT:
+	    ft_options.base.hint_style = CAIRO_HINT_STYLE_SLIGHT;
+	    break;
+	case FC_HINT_MEDIUM:
+	default:
+	    ft_options.base.hint_style = CAIRO_HINT_STYLE_MEDIUM;
+	    break;
+	case FC_HINT_FULL:
+	    ft_options.base.hint_style = CAIRO_HINT_STYLE_FULL;
+	    break;
+	}
+#else /* !FC_HINT_STYLE */
+	if (!hinting) {
+	    ft_options.base.hint_style = CAIRO_HINT_STYLE_NONE;
+	}
+#endif /* FC_HINT_STYLE */
+
+	/* Force embedded bitmaps off if no hinting requested */
+	if (ft_options.base.hint_style == CAIRO_HINT_STYLE_NONE)
+	  bitmap = FcFalse;
+
+	if (!bitmap)
+	    ft_options.load_flags |= FT_LOAD_NO_BITMAP;
+
+    } else {
+	ft_options.base.antialias = CAIRO_ANTIALIAS_NONE;
+    }
+
+    /* force autohinting if requested */
+    if (FcPatternGetBool (pattern,
+			  FC_AUTOHINT, 0, &autohint) != FcResultMatch)
+	autohint = FcFalse;
+
+    if (autohint)
+	ft_options.load_flags |= FT_LOAD_FORCE_AUTOHINT;
+
+    if (FcPatternGetBool (pattern,
+			  FC_VERTICAL_LAYOUT, 0, &vertical_layout) != FcResultMatch)
+	vertical_layout = FcFalse;
+
+    if (vertical_layout)
+	ft_options.load_flags |= FT_LOAD_VERTICAL_LAYOUT;
+    
+#ifndef FC_EMBOLDEN
+#define FC_EMBOLDEN "embolden"
+#endif
+    if (FcPatternGetBool (pattern,
+			  FC_EMBOLDEN, 0, &embolden) != FcResultMatch)
+	embolden = FcFalse;
+    
+    if (embolden)
+	ft_options.extra_flags |= CAIRO_FT_OPTIONS_EMBOLDEN;
+
+    *ret = ft_options;
+}
+
+static void
+_cairo_ft_options_merge (cairo_ft_options_t *options,
+			 cairo_ft_options_t *other)
+{
+    int load_flags = other->load_flags;
+    int load_target = FT_LOAD_TARGET_NORMAL;
+
+    /* clear load target mode */
+    load_flags &= ~(FT_LOAD_TARGET_(FT_LOAD_TARGET_MODE(other->load_flags)));
+    
+    if (load_flags & FT_LOAD_NO_HINTING)
+	other->base.hint_style = CAIRO_HINT_STYLE_NONE;
+
+    if (other->base.antialias == CAIRO_ANTIALIAS_NONE ||
+	options->base.antialias == CAIRO_ANTIALIAS_NONE) {
+	options->base.antialias = CAIRO_ANTIALIAS_NONE;
+	options->base.subpixel_order = CAIRO_SUBPIXEL_ORDER_DEFAULT;
+    }
+
+    if (other->base.antialias == CAIRO_ANTIALIAS_SUBPIXEL &&
+	(options->base.antialias == CAIRO_ANTIALIAS_DEFAULT || 
+	 options->base.antialias == CAIRO_ANTIALIAS_GRAY)) {
+	options->base.antialias = CAIRO_ANTIALIAS_SUBPIXEL;
+	options->base.subpixel_order = other->base.subpixel_order;
+    }
+
+    if (options->base.hint_style == CAIRO_HINT_STYLE_DEFAULT)
+	options->base.hint_style = other->base.hint_style;
+
+    if (other->base.hint_style == CAIRO_HINT_STYLE_NONE)
+	options->base.hint_style = CAIRO_HINT_STYLE_NONE;
+
+    if (options->base.antialias == CAIRO_ANTIALIAS_NONE) {
+	if (options->base.hint_style == CAIRO_HINT_STYLE_NONE)
+	    load_flags |= FT_LOAD_NO_HINTING;
+	else
+	    load_target = FT_LOAD_TARGET_MONO;
+	load_flags |= FT_LOAD_MONOCHROME;
+    } else {
+	switch (options->base.hint_style) {
+	case CAIRO_HINT_STYLE_NONE:
+	    load_flags |= FT_LOAD_NO_HINTING;
+	    break;
+	case CAIRO_HINT_STYLE_SLIGHT:
+	    load_target = FT_LOAD_TARGET_LIGHT;
+	    break;
+	case CAIRO_HINT_STYLE_MEDIUM:
+	    break;
+	case CAIRO_HINT_STYLE_FULL:
+	case CAIRO_HINT_STYLE_DEFAULT:
+	    if (options->base.antialias == CAIRO_ANTIALIAS_SUBPIXEL) {
+		switch (options->base.subpixel_order) {
+		case CAIRO_SUBPIXEL_ORDER_DEFAULT:
+		case CAIRO_SUBPIXEL_ORDER_RGB:
+		case CAIRO_SUBPIXEL_ORDER_BGR:
+		    load_target |= FT_LOAD_TARGET_LCD;
+		    break;
+		case CAIRO_SUBPIXEL_ORDER_VRGB:
+		case CAIRO_SUBPIXEL_ORDER_VBGR:
+		    load_target |= FT_LOAD_TARGET_LCD_V;
+		break;
+		}
+	    }
+	    break;
+	}
+    }
+
+    options->load_flags = load_flags | load_target;
+    options->extra_flags = other->extra_flags;
+    if (options->base.hint_metrics != CAIRO_HINT_METRICS_OFF)
+	options->extra_flags |= CAIRO_FT_OPTIONS_HINT_METRICS;
+}
+
+static cairo_status_t
+_cairo_ft_scaled_font_create (cairo_ft_unscaled_font_t	 *unscaled,
+			      cairo_font_face_t		 *font_face,
+			      const cairo_matrix_t	 *font_matrix,
+			      const cairo_matrix_t	 *ctm,
+			      const cairo_font_options_t *options,
+			      cairo_ft_options_t	  ft_options,
+			      cairo_scaled_font_t       **font_out)
+{
+    cairo_ft_scaled_font_t *scaled_font;
+    FT_Face face;
+    FT_Size_Metrics *metrics;
+    cairo_font_extents_t fs_metrics;
+    cairo_status_t status;
+
+    face = _cairo_ft_unscaled_font_lock_face (unscaled);
+    if (!face)
+	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+    scaled_font = malloc (sizeof(cairo_ft_scaled_font_t));
+    if (scaled_font == NULL) {
+	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	goto FAIL;
+    }
+
+    _cairo_unscaled_font_reference (&unscaled->base);
+    scaled_font->unscaled = unscaled;
+
+    _cairo_font_options_init_copy (&scaled_font->ft_options.base, options);
+    _cairo_ft_options_merge (&scaled_font->ft_options, &ft_options);
+
+    status = _cairo_scaled_font_init (&scaled_font->base,
+			              font_face,
+				      font_matrix, ctm, options,
+				      &_cairo_ft_scaled_font_backend);
+    if (status) {
+	_cairo_unscaled_font_destroy (&unscaled->base);
+	free (scaled_font);
+	goto FAIL;
+    }
+
+    status = _cairo_ft_unscaled_font_set_scale (unscaled,
+				                &scaled_font->base.scale);
+    if (status) {
+	_cairo_unscaled_font_destroy (&unscaled->base);
+	free (scaled_font);
+	goto FAIL;
+    }
+
+
+    metrics = &face->size->metrics;
+
+    /*
+     * Get to unscaled metrics so that the upper level can get back to
+     * user space
+     *
+     * Also use this path for bitmap-only fonts.  The other branch uses
+     * face members that are only relevant for scalable fonts.  This is
+     * detected by simply checking for units_per_EM==0.
+     */
+    if (scaled_font->base.options.hint_metrics != CAIRO_HINT_METRICS_OFF ||
+	face->units_per_EM == 0) {
+	double x_factor, y_factor;
+
+	if (unscaled->x_scale == 0)
+	    x_factor = 0;
+	else
+	    x_factor = 1 / unscaled->x_scale;
+
+	if (unscaled->y_scale == 0)
+	    y_factor = 0;
+	else
+	    y_factor = 1 / unscaled->y_scale;
+
+	fs_metrics.ascent =        DOUBLE_FROM_26_6(metrics->ascender) * y_factor;
+	fs_metrics.descent =       DOUBLE_FROM_26_6(- metrics->descender) * y_factor;
+	fs_metrics.height =        DOUBLE_FROM_26_6(metrics->height) * y_factor;
+	if (!_cairo_ft_scaled_font_is_vertical (&scaled_font->base)) {
+	    fs_metrics.max_x_advance = DOUBLE_FROM_26_6(metrics->max_advance) * x_factor;
+	    fs_metrics.max_y_advance = 0;
+	} else {
+	    fs_metrics.max_x_advance = 0;
+	    fs_metrics.max_y_advance = DOUBLE_FROM_26_6(metrics->max_advance) * y_factor;
+	}
+    } else {
+	double scale = face->units_per_EM;
+
+	fs_metrics.ascent =        face->ascender / scale;
+	fs_metrics.descent =       - face->descender / scale;
+	fs_metrics.height =        face->height / scale;
+	if (!_cairo_ft_scaled_font_is_vertical (&scaled_font->base)) {
+	    fs_metrics.max_x_advance = face->max_advance_width / scale;
+	    fs_metrics.max_y_advance = 0;
+	} else {
+	    fs_metrics.max_x_advance = 0;
+	    fs_metrics.max_y_advance = face->max_advance_height / scale;
+	}
+    }
+
+    status = _cairo_scaled_font_set_metrics (&scaled_font->base, &fs_metrics);
+
+    *font_out = &scaled_font->base;
+
+ FAIL:
+    _cairo_ft_unscaled_font_unlock_face (unscaled);
+
+    return status;
+}
+
+cairo_bool_t
+_cairo_scaled_font_is_ft (cairo_scaled_font_t *scaled_font)
+{
+    return scaled_font->backend == &_cairo_ft_scaled_font_backend;
+}
+
+static cairo_status_t
+_cairo_ft_scaled_font_create_toy (cairo_toy_font_face_t	      *toy_face,
+				  const cairo_matrix_t	      *font_matrix,
+				  const cairo_matrix_t	      *ctm,
+				  const cairo_font_options_t  *font_options,
+				  cairo_scaled_font_t	     **font)
+{
+    FcPattern *pattern, *resolved;
+    cairo_ft_unscaled_font_t *unscaled;
+    FcResult result;
+    int fcslant;
+    int fcweight;
+    cairo_matrix_t scale;
+    cairo_status_t status;
+    cairo_ft_font_transform_t sf;
+    cairo_ft_options_t ft_options;
+
+    cairo_matrix_multiply (&scale, font_matrix, ctm);
+    status = _compute_transform (&sf, &scale);
+    if (status)
+	return status;
+
+    pattern = FcPatternCreate ();
+    if (!pattern)
+	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+    if (!FcPatternAddString (pattern,
+		             FC_FAMILY, (unsigned char *) toy_face->family))
+    {
+	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	goto FREE_PATTERN;
+    }
+
+    switch (toy_face->slant)
+    {
+    case CAIRO_FONT_SLANT_ITALIC:
+        fcslant = FC_SLANT_ITALIC;
+        break;
+    case CAIRO_FONT_SLANT_OBLIQUE:
+	fcslant = FC_SLANT_OBLIQUE;
+        break;
+    case CAIRO_FONT_SLANT_NORMAL:
+    default:
+        fcslant = FC_SLANT_ROMAN;
+        break;
+    }
+
+    if (!FcPatternAddInteger (pattern, FC_SLANT, fcslant)) {
+	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	goto FREE_PATTERN;
+    }
+
+    switch (toy_face->weight)
+    {
+    case CAIRO_FONT_WEIGHT_BOLD:
+        fcweight = FC_WEIGHT_BOLD;
+        break;
+    case CAIRO_FONT_WEIGHT_NORMAL:
+    default:
+        fcweight = FC_WEIGHT_MEDIUM;
+        break;
+    }
+
+    if (!FcPatternAddInteger (pattern, FC_WEIGHT, fcweight)) {
+	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	goto FREE_PATTERN;
+    }
+
+    if (! FcPatternAddDouble (pattern, FC_PIXEL_SIZE, sf.y_scale)) {
+	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	goto FREE_PATTERN;
+    }
+
+    if (! FcConfigSubstitute (NULL, pattern, FcMatchPattern)) {
+	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	goto FREE_PATTERN;
+    }
+
+    status = _cairo_ft_font_options_substitute (font_options, pattern);
+    if (status)
+	goto FREE_PATTERN;
+
+    FcDefaultSubstitute (pattern);
+
+    resolved = FcFontMatch (NULL, pattern, &result);
+    if (!resolved) {
+	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	goto FREE_PATTERN;
+    }
+
+    unscaled = _cairo_ft_unscaled_font_create_for_pattern (resolved);
+    if (!unscaled) {
+	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	goto FREE_RESOLVED;
+    }
+
+    _get_pattern_ft_options (resolved, &ft_options);
+
+    status = _cairo_ft_scaled_font_create (unscaled,
+					   &toy_face->base,
+					   font_matrix, ctm,
+					   font_options, ft_options,
+					   font);
+
+    _cairo_unscaled_font_destroy (&unscaled->base);
+
+ FREE_RESOLVED:
+    FcPatternDestroy (resolved);
+
+ FREE_PATTERN:
+    FcPatternDestroy (pattern);
+
+    return status;
+}
+
+static void
+_cairo_ft_scaled_font_fini (void *abstract_font)
+{
+    cairo_ft_scaled_font_t *scaled_font = abstract_font;
+
+    if (scaled_font == NULL)
+        return;
+
+    _cairo_unscaled_font_destroy (&scaled_font->unscaled->base);
+}
+
+static int
+_move_to (FT_Vector *to, void *closure)
+{
+    cairo_path_fixed_t *path = closure;
+    cairo_fixed_t x, y;
+
+    x = _cairo_fixed_from_26_6 (to->x);
+    y = _cairo_fixed_from_26_6 (to->y);
+
+    if (_cairo_path_fixed_close_path (path) != CAIRO_STATUS_SUCCESS)
+	return 1;
+    if (_cairo_path_fixed_move_to (path, x, y) != CAIRO_STATUS_SUCCESS)
+	return 1;
+
+    return 0;
+}
+
+static int
+_line_to (FT_Vector *to, void *closure)
+{
+    cairo_path_fixed_t *path = closure;
+    cairo_fixed_t x, y;
+
+    x = _cairo_fixed_from_26_6 (to->x);
+    y = _cairo_fixed_from_26_6 (to->y);
+
+    if (_cairo_path_fixed_line_to (path, x, y) != CAIRO_STATUS_SUCCESS)
+	return 1;
+
+    return 0;
+}
+
+static int
+_conic_to (FT_Vector *control, FT_Vector *to, void *closure)
+{
+    cairo_path_fixed_t *path = closure;
+
+    cairo_fixed_t x0, y0;
+    cairo_fixed_t x1, y1;
+    cairo_fixed_t x2, y2;
+    cairo_fixed_t x3, y3;
+    cairo_point_t conic;
+
+    if (! _cairo_path_fixed_get_current_point (path, &x0, &y0))
+	return 1;
+
+    conic.x = _cairo_fixed_from_26_6 (control->x);
+    conic.y = _cairo_fixed_from_26_6 (control->y);
+
+    x3 = _cairo_fixed_from_26_6 (to->x);
+    y3 = _cairo_fixed_from_26_6 (to->y);
+
+    x1 = x0 + 2.0/3.0 * (conic.x - x0);
+    y1 = y0 + 2.0/3.0 * (conic.y - y0);
+
+    x2 = x3 + 2.0/3.0 * (conic.x - x3);
+    y2 = y3 + 2.0/3.0 * (conic.y - y3);
+
+    if (_cairo_path_fixed_curve_to (path,
+				    x1, y1,
+				    x2, y2,
+				    x3, y3) != CAIRO_STATUS_SUCCESS)
+	return 1;
+
+    return 0;
+}
+
+static int
+_cubic_to (FT_Vector *control1, FT_Vector *control2,
+	   FT_Vector *to, void *closure)
+{
+    cairo_path_fixed_t *path = closure;
+    cairo_fixed_t x0, y0;
+    cairo_fixed_t x1, y1;
+    cairo_fixed_t x2, y2;
+
+    x0 = _cairo_fixed_from_26_6 (control1->x);
+    y0 = _cairo_fixed_from_26_6 (control1->y);
+
+    x1 = _cairo_fixed_from_26_6 (control2->x);
+    y1 = _cairo_fixed_from_26_6 (control2->y);
+
+    x2 = _cairo_fixed_from_26_6 (to->x);
+    y2 = _cairo_fixed_from_26_6 (to->y);
+
+    if (_cairo_path_fixed_curve_to (path,
+				    x0, y0,
+				    x1, y1,
+				    x2, y2) != CAIRO_STATUS_SUCCESS)
+	return 1;
+
+    return 0;
+}
+
+static cairo_status_t
+_decompose_glyph_outline (FT_Face		  face,
+			  cairo_font_options_t	 *options,
+			  cairo_path_fixed_t	**pathp)
+{
+    static const FT_Outline_Funcs outline_funcs = {
+	(FT_Outline_MoveToFunc)_move_to,
+	(FT_Outline_LineToFunc)_line_to,
+	(FT_Outline_ConicToFunc)_conic_to,
+	(FT_Outline_CubicToFunc)_cubic_to,
+	0, /* shift */
+	0, /* delta */
+    };
+    static const FT_Matrix invert_y = {
+	DOUBLE_TO_16_16 (1.0), 0,
+	0, DOUBLE_TO_16_16 (-1.0),
+    };
+
+    FT_GlyphSlot glyph;
+    cairo_path_fixed_t *path;
+    cairo_status_t status;
+
+    path = _cairo_path_fixed_create ();
+    if (!path)
+	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+    glyph = face->glyph;
+
+    /* Font glyphs have an inverted Y axis compared to cairo. */
+    FT_Outline_Transform (&glyph->outline, &invert_y);
+    if (FT_Outline_Decompose (&glyph->outline, &outline_funcs, path)) {
+	_cairo_path_fixed_destroy (path);
+	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    }
+
+    status = _cairo_path_fixed_close_path (path);
+    if (status) {
+	_cairo_path_fixed_destroy (path);
+	return status;
+    }
+
+    *pathp = path;
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+/*
+ * Translate glyph to match its metrics.
+ */
+static void
+_cairo_ft_scaled_glyph_vertical_layout_bearing_fix (void        *abstract_font,
+						    FT_GlyphSlot glyph)
+{
+    cairo_ft_scaled_font_t *scaled_font = abstract_font;
+    FT_Vector vector;
+
+    vector.x = glyph->metrics.vertBearingX - glyph->metrics.horiBearingX;
+    vector.y = -glyph->metrics.vertBearingY - glyph->metrics.horiBearingY;
+
+    if (glyph->format == FT_GLYPH_FORMAT_OUTLINE) {
+	FT_Vector_Transform (&vector, &scaled_font->unscaled->Current_Shape);
+	FT_Outline_Translate(&glyph->outline, vector.x, vector.y);
+    } else if (glyph->format == FT_GLYPH_FORMAT_BITMAP) {
+	glyph->bitmap_left += vector.x / 64;
+	glyph->bitmap_top  += vector.y / 64;
+    }
+}
+
+static cairo_int_status_t
+_cairo_ft_scaled_glyph_init (void			*abstract_font,
+			     cairo_scaled_glyph_t	*scaled_glyph,
+			     cairo_scaled_glyph_info_t	 info)
+{
+    cairo_text_extents_t    fs_metrics;
+    cairo_ft_scaled_font_t *scaled_font = abstract_font;
+    cairo_ft_unscaled_font_t *unscaled = scaled_font->unscaled;
+    FT_GlyphSlot glyph;
+    FT_Face face;
+    FT_Error error;
+    int load_flags = scaled_font->ft_options.load_flags;
+    FT_Glyph_Metrics *metrics;
+    double x_factor, y_factor;
+    cairo_bool_t vertical_layout = FALSE;
+    cairo_status_t status;
+
+    face = _cairo_ft_unscaled_font_lock_face (unscaled);
+    if (!face)
+	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+    status = _cairo_ft_unscaled_font_set_scale (scaled_font->unscaled,
+				                &scaled_font->base.scale);
+    if (status)
+	goto FAIL;
+
+    /* Ignore global advance unconditionally */
+    load_flags |= FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH;
+
+    if ((info & CAIRO_SCALED_GLYPH_INFO_PATH) != 0 &&
+	(info & CAIRO_SCALED_GLYPH_INFO_SURFACE) == 0)
+	load_flags |= FT_LOAD_NO_BITMAP;
+
+    /*
+     * Don't pass FT_LOAD_VERTICAL_LAYOUT to FT_Load_Glyph here as
+     * suggested by freetype people.
+     */
+    if (load_flags & FT_LOAD_VERTICAL_LAYOUT) {
+	load_flags &= ~FT_LOAD_VERTICAL_LAYOUT;
+	vertical_layout = TRUE;
+    }
+
+    error = FT_Load_Glyph (scaled_font->unscaled->face,
+			   _cairo_scaled_glyph_index(scaled_glyph),
+			   load_flags);
+    /* XXX ignoring all other errors for now.  They are not fatal, typically
+     * just a glyph-not-found. */
+    if (error == FT_Err_Out_Of_Memory) {
+	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	goto FAIL;
+    }
+
+    glyph = face->glyph;
+
+#if HAVE_FT_GLYPHSLOT_EMBOLDEN
+    /*
+     * embolden glyphs if requested
+     */
+    if (scaled_font->ft_options.extra_flags & CAIRO_FT_OPTIONS_EMBOLDEN)
+	FT_GlyphSlot_Embolden (glyph);
+#endif
+
+    if (vertical_layout)
+	_cairo_ft_scaled_glyph_vertical_layout_bearing_fix (scaled_font, glyph);
+
+    if (info & CAIRO_SCALED_GLYPH_INFO_METRICS) {
+
+	cairo_bool_t hint_metrics = scaled_font->base.options.hint_metrics != CAIRO_HINT_METRICS_OFF;
+	/*
+	 * Compute font-space metrics
+	 */
+	metrics = &glyph->metrics;
+
+	if (unscaled->x_scale == 0)
+	    x_factor = 0;
+	else
+	    x_factor = 1 / unscaled->x_scale;
+
+	if (unscaled->y_scale == 0)
+	    y_factor = 0;
+	else
+	    y_factor = 1 / unscaled->y_scale;
+
+	/*
+	 * Note: Y coordinates of the horizontal bearing need to be negated.
+	 *
+	 * Scale metrics back to glyph space from the scaled glyph space returned
+	 * by FreeType
+	 *
+	 * If we want hinted metrics but aren't asking for hinted glyphs from
+	 * FreeType, then we need to do the metric hinting ourselves.
+	 */
+
+	if (hint_metrics && (load_flags & FT_LOAD_NO_HINTING))
+	{
+	    FT_Pos x1, x2;
+	    FT_Pos y1, y2;
+	    FT_Pos advance;
+	    
+	    if (!vertical_layout) {
+		x1 = (metrics->horiBearingX) & -64;
+		x2 = (metrics->horiBearingX + metrics->width + 63) & -64;
+		y1 = (-metrics->horiBearingY) & -64;
+		y2 = (-metrics->horiBearingY + metrics->height + 63) & -64;
+		
+		advance = ((metrics->horiAdvance + 32) & -64);
+		
+		fs_metrics.x_bearing = DOUBLE_FROM_26_6 (x1) * x_factor;
+		fs_metrics.y_bearing = DOUBLE_FROM_26_6 (y1) * y_factor;
+		
+		fs_metrics.width  = DOUBLE_FROM_26_6 (x2 - x1) * x_factor;
+		fs_metrics.height  = DOUBLE_FROM_26_6 (y2 - y1) * y_factor;
+
+		fs_metrics.x_advance = DOUBLE_FROM_26_6 (advance) * x_factor;
+		fs_metrics.y_advance = 0;
+	    } else {
+		x1 = (metrics->vertBearingX) & -64;
+		x2 = (metrics->vertBearingX + metrics->width + 63) & -64;
+		y1 = (metrics->vertBearingY) & -64;
+		y2 = (metrics->vertBearingY + metrics->height + 63) & -64;
+		
+		advance = ((metrics->vertAdvance + 32) & -64);
+		
+		fs_metrics.x_bearing = DOUBLE_FROM_26_6 (x1) * x_factor;
+		fs_metrics.y_bearing = DOUBLE_FROM_26_6 (y1) * y_factor;
+		
+		fs_metrics.width  = DOUBLE_FROM_26_6 (x2 - x1) * x_factor;
+		fs_metrics.height  = DOUBLE_FROM_26_6 (y2 - y1) * y_factor;
+
+		fs_metrics.x_advance = 0;
+		fs_metrics.y_advance = DOUBLE_FROM_26_6 (advance) * y_factor;
+	    }
+	 } else {
+	    fs_metrics.width  = DOUBLE_FROM_26_6 (metrics->width) * x_factor;
+	    fs_metrics.height = DOUBLE_FROM_26_6 (metrics->height) * y_factor;
+
+	    if (!vertical_layout) {
+		fs_metrics.x_bearing = DOUBLE_FROM_26_6 (metrics->horiBearingX) * x_factor;
+		fs_metrics.y_bearing = DOUBLE_FROM_26_6 (-metrics->horiBearingY) * y_factor;
+		
+		if (hint_metrics || glyph->format != FT_GLYPH_FORMAT_OUTLINE)
+		    fs_metrics.x_advance = DOUBLE_FROM_26_6 (metrics->horiAdvance) * x_factor;
+		else
+		    fs_metrics.x_advance = DOUBLE_FROM_16_16 (glyph->linearHoriAdvance) * x_factor;
+		fs_metrics.y_advance = 0 * y_factor;
+	    } else {
+		fs_metrics.x_bearing = DOUBLE_FROM_26_6 (metrics->vertBearingX) * x_factor;
+		fs_metrics.y_bearing = DOUBLE_FROM_26_6 (metrics->vertBearingY) * y_factor;
+		
+		fs_metrics.x_advance = 0 * x_factor;
+		if (hint_metrics || glyph->format != FT_GLYPH_FORMAT_OUTLINE)
+		    fs_metrics.y_advance = DOUBLE_FROM_26_6 (metrics->vertAdvance) * y_factor;
+		else
+		    fs_metrics.y_advance = DOUBLE_FROM_26_6 (glyph->linearVertAdvance) * y_factor;
+	    }
+	 }
+
+	_cairo_scaled_glyph_set_metrics (scaled_glyph,
+					 &scaled_font->base,
+					 &fs_metrics);
+    }
+
+    if ((info & CAIRO_SCALED_GLYPH_INFO_SURFACE) != 0) {
+	cairo_image_surface_t	*surface;
+
+	if (glyph->format == FT_GLYPH_FORMAT_OUTLINE) {
+	    status = _render_glyph_outline (face, &scaled_font->ft_options.base,
+					    &surface);
+	} else {
+	    status = _render_glyph_bitmap (face, &scaled_font->ft_options.base,
+					   &surface);
+	    if (status == CAIRO_STATUS_SUCCESS && unscaled->have_shape) {
+		status = _transform_glyph_bitmap (&unscaled->current_shape,
+						  &surface);
+		if (status)
+		    cairo_surface_destroy (&surface->base);
+	    }
+	}
+	if (status)
+	    goto FAIL;
+
+	_cairo_scaled_glyph_set_surface (scaled_glyph,
+					 &scaled_font->base,
+					 surface);
+    }
+
+    if (info & CAIRO_SCALED_GLYPH_INFO_PATH) {
+	cairo_path_fixed_t *path = NULL; /* hide compiler warning */
+
+	/*
+	 * A kludge -- the above code will trash the outline,
+	 * so reload it. This will probably never occur though
+	 */
+	if ((info & CAIRO_SCALED_GLYPH_INFO_SURFACE) != 0) {
+	    error = FT_Load_Glyph (face,
+				   _cairo_scaled_glyph_index(scaled_glyph),
+				   load_flags | FT_LOAD_NO_BITMAP);
+	    /* XXX ignoring all other errors for now.  They are not fatal, typically
+	     * just a glyph-not-found. */
+	    if (error == FT_Err_Out_Of_Memory) {
+		status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+		goto FAIL;
+	    }
+#if HAVE_FT_GLYPHSLOT_EMBOLDEN
+	    /*
+	     * embolden glyphs if requested
+	     */
+	    if (scaled_font->ft_options.extra_flags & CAIRO_FT_OPTIONS_EMBOLDEN)
+		FT_GlyphSlot_Embolden (glyph);
+#endif
+	    if (vertical_layout)
+		_cairo_ft_scaled_glyph_vertical_layout_bearing_fix (scaled_font, glyph);
+
+	}
+	if (glyph->format == FT_GLYPH_FORMAT_OUTLINE)
+	    status = _decompose_glyph_outline (face, &scaled_font->ft_options.base,
+					       &path);
+	else
+	    status = CAIRO_INT_STATUS_UNSUPPORTED;
+
+	if (status)
+	    goto FAIL;
+
+	_cairo_scaled_glyph_set_path (scaled_glyph,
+				      &scaled_font->base,
+				      path);
+    }
+ FAIL:
+    _cairo_ft_unscaled_font_unlock_face (unscaled);
+
+    return status;
+}
+
+static unsigned long
+_cairo_ft_ucs4_to_index (void	    *abstract_font,
+			 uint32_t    ucs4)
+{
+    cairo_ft_scaled_font_t *scaled_font = abstract_font;
+    cairo_ft_unscaled_font_t *unscaled = scaled_font->unscaled;
+    FT_Face face;
+    FT_UInt index;
+
+    face = _cairo_ft_unscaled_font_lock_face (unscaled);
+    if (!face)
+	return 0;
+
+    /* If making this compile without fontconfig, use:
+     * index = FT_Get_Char_Index (face, ucs4); */
+    index = FcFreeTypeCharIndex (face, ucs4);
+
+    _cairo_ft_unscaled_font_unlock_face (unscaled);
+    return index;
+}
+
+static cairo_int_status_t
+_cairo_ft_load_truetype_table (void	       *abstract_font,
+                              unsigned long     tag,
+                              long              offset,
+                              unsigned char    *buffer,
+                              unsigned long    *length)
+{
+    cairo_ft_scaled_font_t *scaled_font = abstract_font;
+    cairo_ft_unscaled_font_t *unscaled = scaled_font->unscaled;
+    FT_Face face;
+    cairo_status_t status = CAIRO_INT_STATUS_UNSUPPORTED;
+
+    if (_cairo_ft_scaled_font_is_vertical (&scaled_font->base))
+        return CAIRO_INT_STATUS_UNSUPPORTED;
+
+#if HAVE_FT_LOAD_SFNT_TABLE
+    face = _cairo_ft_unscaled_font_lock_face (unscaled);
+    if (!face)
+	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+    if (FT_IS_SFNT (face) &&
+	FT_Load_Sfnt_Table (face, tag, offset, buffer, length) == 0)
+        status = CAIRO_STATUS_SUCCESS;
+
+    _cairo_ft_unscaled_font_unlock_face (unscaled);
+#endif
+
+    return status;
+}
+
+static cairo_int_status_t
+_cairo_ft_index_to_ucs4(void	        *abstract_font,
+			unsigned long    index,
+			uint32_t	*ucs4)
+{
+    cairo_ft_scaled_font_t *scaled_font = abstract_font;
+    cairo_ft_unscaled_font_t *unscaled = scaled_font->unscaled;
+    FT_Face face;
+    FT_ULong  charcode;
+    FT_UInt   gindex;
+
+    face = _cairo_ft_unscaled_font_lock_face (unscaled);
+    if (!face)
+	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+    *ucs4 = (uint32_t) -1;
+    charcode = FT_Get_First_Char(face, &gindex);
+    while (gindex != 0) {
+	charcode = FT_Get_Next_Char (face, charcode, &gindex);
+	if (gindex == index) {
+	    *ucs4 = charcode;
+	    break;
+	}
+    }
+
+    _cairo_ft_unscaled_font_unlock_face (unscaled);
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+const cairo_scaled_font_backend_t _cairo_ft_scaled_font_backend = {
+    CAIRO_FONT_TYPE_FT,
+    NULL,
+    _cairo_ft_scaled_font_create_toy,
+    _cairo_ft_scaled_font_fini,
+    _cairo_ft_scaled_glyph_init,
+    NULL,			/* text_to_glyphs */
+    _cairo_ft_ucs4_to_index,
+    NULL, 			/* show_glyphs */
+    _cairo_ft_load_truetype_table,
+    _cairo_ft_index_to_ucs4
+};
+
+/* #cairo_ft_font_face_t */
+
+static void
+_cairo_ft_font_face_destroy (void *abstract_face)
+{
+    cairo_ft_font_face_t *font_face = abstract_face;
+
+    cairo_ft_font_face_t *tmp_face = NULL;
+    cairo_ft_font_face_t *last_face = NULL;
+
+    if (font_face == NULL)
+	return;
+
+    /* When destroying the face created by cairo_ft_font_face_create_for_ft_face,
+     * we have a special "zombie" state for the face when the unscaled font
+     * is still alive but there are no public references to the font face.
+     *
+     * We go from:
+     *
+     *   font_face ------> unscaled
+     *        <-....weak....../
+     *
+     * To:
+     *
+     *    font_face <------- unscaled
+     */
+
+    if (font_face->unscaled &&
+	font_face->unscaled->from_face &&
+	CAIRO_REFERENCE_COUNT_GET_VALUE (&font_face->unscaled->base.ref_count) > 1)
+    {
+	cairo_font_face_reference (&font_face->base);
+
+	_cairo_unscaled_font_destroy (&font_face->unscaled->base);
+	font_face->unscaled = NULL;
+
+	return;
+    }
+
+    if (font_face->unscaled) {
+	/* Remove face from linked list */
+	for (tmp_face = font_face->unscaled->faces;
+	     tmp_face;
+	     tmp_face = tmp_face->next)
+	{
+	    if (tmp_face == font_face) {
+		if (last_face)
+		    last_face->next = tmp_face->next;
+		else
+		    font_face->unscaled->faces = tmp_face->next;
+	    }
+
+	    last_face = tmp_face;
+	}
+
+	_cairo_unscaled_font_destroy (&font_face->unscaled->base);
+	font_face->unscaled = NULL;
+    }
+}
+
+static cairo_status_t
+_cairo_ft_font_face_scaled_font_create (void                     *abstract_face,
+					const cairo_matrix_t       *font_matrix,
+					const cairo_matrix_t       *ctm,
+					const cairo_font_options_t *options,
+					cairo_scaled_font_t       **scaled_font)
+{
+    cairo_ft_font_face_t *font_face = abstract_face;
+    cairo_ft_options_t ft_options;
+
+    /* The handling of font options is different depending on how the
+     * font face was created. When the user creates a font face with
+     * cairo_ft_font_face_create_for_ft_face(), then the load flags
+     * passed in augment the load flags for the options.  But for
+     * cairo_ft_font_face_create_for_pattern(), the load flags are
+     * derived from a pattern where the user has called
+     * cairo_ft_font_options_substitute(), so *just* use those load
+     * flags and ignore the options.
+     *
+     * XXX two points about the above comment:
+     * 1. I don't see how the comment is relevant here,
+     * 2. What if the face is coming from FC_FT_FACE of a pattern?
+     */
+
+    ft_options = font_face->ft_options;
+
+    return  _cairo_ft_scaled_font_create (font_face->unscaled,
+					  &font_face->base,
+					  font_matrix, ctm,
+					  options, ft_options,
+					  scaled_font);
+}
+
+static const cairo_font_face_backend_t _cairo_ft_font_face_backend = {
+    CAIRO_FONT_TYPE_FT,
+    _cairo_ft_font_face_destroy,
+    NULL, /* direct implementation */
+    _cairo_ft_font_face_scaled_font_create
+};
+
+static cairo_font_face_t *
+_cairo_ft_font_face_create (cairo_ft_unscaled_font_t *unscaled,
+			    cairo_ft_options_t	     *ft_options)
+{
+    cairo_ft_font_face_t *font_face, **prev_font_face;
+
+    /* Looked for an existing matching font face */
+    for (font_face = unscaled->faces, prev_font_face = &unscaled->faces;
+	 font_face;
+	 prev_font_face = &font_face->next, font_face = font_face->next)
+    {
+	if (font_face->ft_options.load_flags == ft_options->load_flags &&
+	    font_face->ft_options.extra_flags == ft_options->extra_flags &&
+	    cairo_font_options_equal (&font_face->ft_options.base, &ft_options->base))
+	{
+	    if (font_face->base.status == CAIRO_STATUS_SUCCESS)
+		return cairo_font_face_reference (&font_face->base);
+
+	    /* The font_face has been left in an error state, abandon it. */
+	    *prev_font_face = font_face->next;
+	    break;
+	}
+    }
+
+    /* No match found, create a new one */
+    font_face = malloc (sizeof (cairo_ft_font_face_t));
+    if (!font_face) {
+	_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
+	return (cairo_font_face_t *)&_cairo_font_face_nil;
+    }
+
+    font_face->unscaled = unscaled;
+    _cairo_unscaled_font_reference (&unscaled->base);
+
+    font_face->ft_options = *ft_options;
+
+    font_face->next = unscaled->faces;
+    unscaled->faces = font_face;
+
+    _cairo_font_face_init (&font_face->base, &_cairo_ft_font_face_backend);
+
+    return &font_face->base;
+}
+
+/* implement the platform-specific interface */
+
+static cairo_status_t
+_cairo_ft_font_options_substitute (const cairo_font_options_t *options,
+				   FcPattern                  *pattern)
+{
+    FcValue v;
+
+    if (options->antialias != CAIRO_ANTIALIAS_DEFAULT)
+    {
+	if (FcPatternGet (pattern, FC_ANTIALIAS, 0, &v) == FcResultNoMatch)
+	{
+	    if (! FcPatternAddBool (pattern,
+			            FC_ANTIALIAS,
+				    options->antialias != CAIRO_ANTIALIAS_NONE))
+		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+	    if (options->antialias != CAIRO_ANTIALIAS_SUBPIXEL) {
+		FcPatternDel (pattern, FC_RGBA);
+		if (! FcPatternAddInteger (pattern, FC_RGBA, FC_RGBA_NONE))
+		    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	    }
+	}
+    }
+
+    if (options->antialias != CAIRO_ANTIALIAS_DEFAULT)
+    {
+	if (FcPatternGet (pattern, FC_RGBA, 0, &v) == FcResultNoMatch)
+	{
+	    int rgba;
+
+	    if (options->antialias == CAIRO_ANTIALIAS_SUBPIXEL) {
+		switch (options->subpixel_order) {
+		case CAIRO_SUBPIXEL_ORDER_DEFAULT:
+		case CAIRO_SUBPIXEL_ORDER_RGB:
+		default:
+		    rgba = FC_RGBA_RGB;
+		    break;
+		case CAIRO_SUBPIXEL_ORDER_BGR:
+		    rgba = FC_RGBA_BGR;
+		    break;
+		case CAIRO_SUBPIXEL_ORDER_VRGB:
+		    rgba = FC_RGBA_VRGB;
+		    break;
+		case CAIRO_SUBPIXEL_ORDER_VBGR:
+		    rgba = FC_RGBA_VBGR;
+		    break;
+		}
+	    } else {
+		rgba = FC_RGBA_NONE;
+	    }
+
+	    if (! FcPatternAddInteger (pattern, FC_RGBA, rgba))
+		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	}
+    }
+
+    if (options->hint_style != CAIRO_HINT_STYLE_DEFAULT)
+    {
+	if (FcPatternGet (pattern, FC_HINTING, 0, &v) == FcResultNoMatch)
+	{
+	    if (! FcPatternAddBool (pattern,
+			            FC_HINTING,
+				    options->hint_style != CAIRO_HINT_STYLE_NONE))
+		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	}
+
+#ifdef FC_HINT_STYLE
+	if (FcPatternGet (pattern, FC_HINT_STYLE, 0, &v) == FcResultNoMatch)
+	{
+	    int hint_style;
+
+	    switch (options->hint_style) {
+	    case CAIRO_HINT_STYLE_NONE:
+		hint_style = FC_HINT_NONE;
+		break;
+	    case CAIRO_HINT_STYLE_SLIGHT:
+		hint_style = FC_HINT_SLIGHT;
+		break;
+	    case CAIRO_HINT_STYLE_MEDIUM:
+		hint_style = FC_HINT_MEDIUM;
+		break;
+	    case CAIRO_HINT_STYLE_FULL:
+	    case CAIRO_HINT_STYLE_DEFAULT:
+	    default:
+		hint_style = FC_HINT_FULL;
+		break;
+	    }
+
+	    if (! FcPatternAddInteger (pattern, FC_HINT_STYLE, hint_style))
+		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	}
+#endif
+    }
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+/**
+ * cairo_ft_font_options_substitute:
+ * @options: a #cairo_font_options_t object
+ * @pattern: an existing #FcPattern
+ *
+ * Add options to a #FcPattern based on a #cairo_font_options_t font
+ * options object. Options that are already in the pattern, are not overridden,
+ * so you should call this function after calling FcConfigSubstitute() (the
+ * user's settings should override options based on the surface type), but
+ * before calling FcDefaultSubstitute().
+ **/
+void
+cairo_ft_font_options_substitute (const cairo_font_options_t *options,
+				  FcPattern                  *pattern)
+{
+    if (cairo_font_options_status ((cairo_font_options_t *) options))
+	return;
+
+    _cairo_ft_font_options_substitute (options, pattern);
+}
+
+/**
+ * cairo_ft_font_face_create_for_pattern:
+ * @pattern: A fully resolved fontconfig
+ *   pattern. A pattern can be resolved, by, among other things, calling
+ *   FcConfigSubstitute(), FcDefaultSubstitute(), then
+ *   FcFontMatch(). Cairo will call FcPatternReference() on this
+ *   pattern, so you should not further modify the pattern, but you can
+ *   release your reference to the pattern with FcPatternDestroy() if
+ *   you no longer need to access it.
+ *
+ * Creates a new font face for the FreeType font backend based on a
+ * fontconfig pattern. This font can then be used with
+ * cairo_set_font_face() or cairo_scaled_font_create(). The
+ * #cairo_scaled_font_t returned from cairo_scaled_font_create() is
+ * also for the FreeType backend and can be used with functions such
+ * as cairo_ft_scaled_font_lock_face().
+ *
+ * Font rendering options are represented both here and when you
+ * call cairo_scaled_font_create(). Font options that have a representation
+ * in a #FcPattern must be passed in here; to modify #FcPattern
+ * appropriately to reflect the options in a #cairo_font_options_t, call
+ * cairo_ft_font_options_substitute().
+ *
+ * The pattern's FC_FT_FACE element is inspected first and if that is set,
+ * that will be the FreeType font face associated with the returned cairo
+ * font face.  Otherwise the FC_FILE and FC_INDEX elements of @pattern are
+ * used to load a font face from file.
+ *
+ * If the FC_FT_FACE element of @pattern is set, the user is responsible
+ * for making sure that the referenced FT_Face remains valid for the life
+ * time of the returned #cairo_font_face_t.  See
+ * cairo_ft_font_face_create_for_ft_face() for an exmaple of how to couple
+ * the life time of the FT_Face to that of the cairo font-face.
+ *
+ * Return value: a newly created #cairo_font_face_t. Free with
+ *  cairo_font_face_destroy() when you are done using it.
+ **/
+cairo_font_face_t *
+cairo_ft_font_face_create_for_pattern (FcPattern *pattern)
+{
+    cairo_ft_unscaled_font_t *unscaled;
+    cairo_font_face_t *font_face;
+    cairo_ft_options_t ft_options;
+
+    unscaled = _cairo_ft_unscaled_font_create_for_pattern (pattern);
+    if (unscaled == NULL) {
+	_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
+	return (cairo_font_face_t *)&_cairo_font_face_nil;
+    }
+
+    _get_pattern_ft_options (pattern, &ft_options);
+    font_face = _cairo_ft_font_face_create (unscaled, &ft_options);
+    _cairo_unscaled_font_destroy (&unscaled->base);
+
+    return font_face;
+}
+
+/**
+ * cairo_ft_font_face_create_for_ft_face:
+ * @face: A FreeType face object, already opened. This must
+ *   be kept around until the face's ref_count drops to
+ *   zero and it is freed. Since the face may be referenced
+ *   internally to Cairo, the best way to determine when it
+ *   is safe to free the face is to pass a
+ *   #cairo_destroy_func_t to cairo_font_face_set_user_data()
+ * @load_flags: flags to pass to FT_Load_Glyph when loading
+ *   glyphs from the font. These flags are OR'ed together with
+ *   the flags derived from the #cairo_font_options_t passed
+ *   to cairo_scaled_font_create(), so only a few values such
+ *   as %FT_LOAD_VERTICAL_LAYOUT, and %FT_LOAD_FORCE_AUTOHINT
+ *   are useful. You should not pass any of the flags affecting
+ *   the load target, such as %FT_LOAD_TARGET_LIGHT.
+ *
+ * Creates a new font face for the FreeType font backend from a
+ * pre-opened FreeType face. This font can then be used with
+ * cairo_set_font_face() or cairo_scaled_font_create(). The
+ * #cairo_scaled_font_t returned from cairo_scaled_font_create() is
+ * also for the FreeType backend and can be used with functions such
+ * as cairo_ft_scaled_font_lock_face(). Note that Cairo may keep a reference
+ * to the FT_Face alive in a font-cache and the exact lifetime of the reference
+ * depends highly upon the exact usage pattern and is subject to external
+ * factors. You must not call FT_Done_Face() before the last reference to the
+ * #cairo_font_face_t has been dropped.
+ *
+ * As an example, below is how one might correctly couple the lifetime of
+ * the FreeType face object to the #cairo_font_face_t.
+ *
+ * <informalexample><programlisting>
+ * static const cairo_user_data_key_t key;
+ *
+ * font_face = cairo_ft_font_face_create_for_ft_face (ft_face, 0);
+ * status = cairo_font_face_set_user_data (font_face, &key,
+ *                                ft_face, (cairo_destroy_func_t) FT_Done_Face);
+ * if (status) {
+ *    cairo_font_face_destroy (font_face);
+ *    FT_Done_Face (ft_face);
+ *    return ERROR;
+ * }
+ * </programlisting></informalexample>
+ *
+ * Return value: a newly created #cairo_font_face_t. Free with
+ *  cairo_font_face_destroy() when you are done using it.
+ **/
+cairo_font_face_t *
+cairo_ft_font_face_create_for_ft_face (FT_Face         face,
+				       int             load_flags)
+{
+    cairo_ft_unscaled_font_t *unscaled;
+    cairo_font_face_t *font_face;
+    cairo_ft_options_t ft_options;
+
+    unscaled = _cairo_ft_unscaled_font_create_from_face (face);
+    if (unscaled == NULL) {
+	_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
+	return (cairo_font_face_t *)&_cairo_font_face_nil;
+    }
+
+    ft_options.load_flags = load_flags;
+    ft_options.extra_flags = 0;
+    _cairo_font_options_init_default (&ft_options.base);
+
+    font_face = _cairo_ft_font_face_create (unscaled, &ft_options);
+    _cairo_unscaled_font_destroy (&unscaled->base);
+
+    return font_face;
+}
+
+/**
+ * cairo_ft_scaled_font_lock_face:
+ * @scaled_font: A #cairo_scaled_font_t from the FreeType font backend. Such an
+ *   object can be created by calling cairo_scaled_font_create() on a
+ *   FreeType backend font face (see cairo_ft_font_face_create_for_pattern(),
+ *   cairo_ft_font_face_create_for_ft_face()).
+ *
+ * cairo_ft_scaled_font_lock_face() gets the #FT_Face object from a FreeType
+ * backend font and scales it appropriately for the font. You must
+ * release the face with cairo_ft_scaled_font_unlock_face()
+ * when you are done using it.  Since the #FT_Face object can be
+ * shared between multiple #cairo_scaled_font_t objects, you must not
+ * lock any other font objects until you unlock this one. A count is
+ * kept of the number of times cairo_ft_scaled_font_lock_face() is
+ * called. cairo_ft_scaled_font_unlock_face() must be called the same number
+ * of times.
+ *
+ * You must be careful when using this function in a library or in a
+ * threaded application, because freetype's design makes it unsafe to
+ * call freetype functions simultaneously from multiple threads, (even
+ * if using distinct FT_Face objects). Because of this, application
+ * code that acquires an FT_Face object with this call must add it's
+ * own locking to protect any use of that object, (and which also must
+ * protect any other calls into cairo as almost any cairo function
+ * might result in a call into the freetype library).
+ *
+ * Return value: The #FT_Face object for @font, scaled appropriately,
+ * or %NULL if @scaled_font is in an error state (see
+ * cairo_scaled_font_status()) or there is insufficient memory.
+ **/
+FT_Face
+cairo_ft_scaled_font_lock_face (cairo_scaled_font_t *abstract_font)
+{
+    cairo_ft_scaled_font_t *scaled_font = (cairo_ft_scaled_font_t *) abstract_font;
+    FT_Face face;
+    cairo_status_t status;
+
+    if (! _cairo_scaled_font_is_ft (abstract_font)) {
+	_cairo_error_throw (CAIRO_STATUS_FONT_TYPE_MISMATCH);
+	return NULL;
+    }
+
+    if (scaled_font->base.status)
+	return NULL;
+
+    face = _cairo_ft_unscaled_font_lock_face (scaled_font->unscaled);
+    if (face == NULL) {
+	status = _cairo_scaled_font_set_error (&scaled_font->base, CAIRO_STATUS_NO_MEMORY);
+	return NULL;
+    }
+
+    status = _cairo_ft_unscaled_font_set_scale (scaled_font->unscaled,
+				                &scaled_font->base.scale);
+    if (status) {
+	_cairo_ft_unscaled_font_unlock_face (scaled_font->unscaled);
+	status = _cairo_scaled_font_set_error (&scaled_font->base, status);
+	return NULL;
+    }
+
+    /* Note: We deliberately release the unscaled font's mutex here,
+     * so that we are not holding a lock across two separate calls to
+     * cairo function, (which would give the application some
+     * opportunity for creating deadlock. This is obviously unsafe,
+     * but as documented, the user must add manual locking when using
+     * this function. */
+     CAIRO_MUTEX_UNLOCK (scaled_font->unscaled->mutex);
+
+    return face;
+}
+
+/**
+ * cairo_ft_scaled_font_unlock_face:
+ * @scaled_font: A #cairo_scaled_font_t from the FreeType font backend. Such an
+ *   object can be created by calling cairo_scaled_font_create() on a
+ *   FreeType backend font face (see cairo_ft_font_face_create_for_pattern(),
+ *   cairo_ft_font_face_create_for_ft_face()).
+ *
+ * Releases a face obtained with cairo_ft_scaled_font_lock_face().
+ **/
+void
+cairo_ft_scaled_font_unlock_face (cairo_scaled_font_t *abstract_font)
+{
+    cairo_ft_scaled_font_t *scaled_font = (cairo_ft_scaled_font_t *) abstract_font;
+
+    if (! _cairo_scaled_font_is_ft (abstract_font)) {
+	_cairo_error_throw (CAIRO_STATUS_FONT_TYPE_MISMATCH);
+	return;
+    }
+
+    if (scaled_font->base.status)
+	return;
+
+    /* Note: We released the unscaled font's mutex at the end of
+     * cairo_ft_scaled_font_lock_face, so we have to acquire it again
+     * as _cairo_ft_unscaled_font_unlock_face expects it to be held
+     * when we call into it. */
+    CAIRO_MUTEX_LOCK (scaled_font->unscaled->mutex);
+
+    _cairo_ft_unscaled_font_unlock_face (scaled_font->unscaled);
+}
+
+/* We expose our unscaled font implementation internally for the the
+ * PDF backend, which needs to keep track of the the different
+ * fonts-on-disk used by a document, so it can embed them.
+ */
+cairo_unscaled_font_t *
+_cairo_ft_scaled_font_get_unscaled_font (cairo_scaled_font_t *abstract_font)
+{
+    cairo_ft_scaled_font_t *scaled_font = (cairo_ft_scaled_font_t *) abstract_font;
+
+    return &scaled_font->unscaled->base;
+}
+
+cairo_bool_t
+_cairo_ft_scaled_font_is_vertical (cairo_scaled_font_t *scaled_font)
+{
+    cairo_ft_scaled_font_t *ft_scaled_font;
+    
+    if (!_cairo_scaled_font_is_ft (scaled_font))
+	return FALSE;
+    
+    ft_scaled_font = (cairo_ft_scaled_font_t *) scaled_font;
+    if (ft_scaled_font->ft_options.load_flags & FT_LOAD_VERTICAL_LAYOUT)
+	return TRUE;
+    return FALSE;
+}
+
+void
+_cairo_ft_font_reset_static_data (void)
+{
+    _cairo_ft_unscaled_font_map_destroy ();
+}
diff -Naur cairo-1.8.4-debian-1/src/cairoint.h cairo-1.8.4-debian-2/src/cairoint.h
--- cairo-1.8.4-debian-1/src/cairoint.h	2008-12-04 19:42:59.000000000 +0100
+++ cairo-1.8.4-debian-2/src/cairoint.h	2008-12-04 19:47:47.000000000 +0100
@@ -1366,6 +1366,13 @@
 _cairo_font_options_init_copy (cairo_font_options_t		*options,
 			       const cairo_font_options_t	*other);
 
+cairo_private void
+_cairo_font_options_set_lcd_filter (cairo_font_options_t   *options,
+				   cairo_lcd_filter_t  lcd_filter);
+
+cairo_private cairo_lcd_filter_t
+_cairo_font_options_get_lcd_filter (const cairo_font_options_t *options);
+
 /* cairo-hull.c */
 cairo_private cairo_status_t
 _cairo_hull_compute (cairo_pen_vertex_t *vertices, int *num_vertices);
diff -Naur cairo-1.8.4-debian-1/src/cairoint.h.orig cairo-1.8.4-debian-2/src/cairoint.h.orig
--- cairo-1.8.4-debian-1/src/cairoint.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ cairo-1.8.4-debian-2/src/cairoint.h.orig	2008-12-04 19:47:17.000000000 +0100
@@ -0,0 +1,2539 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+/*
+ * These definitions are solely for use by the implementation of cairo
+ * and constitute no kind of standard.  If you need any of these
+ * functions, please drop me a note.  Either the library needs new
+ * functionality, or there's a way to do what you need using the
+ * existing published interfaces. cworth@cworth.org
+ */
+
+#ifndef _CAIROINT_H_
+#define _CAIROINT_H_
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _MSC_VER
+#define cairo_public __declspec(dllexport)
+#endif
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stddef.h>
+
+#ifdef _MSC_VER
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#include <limits.h>
+#include <stdio.h>
+
+#include "cairo.h"
+#include <pixman.h>
+
+#include "cairo-compiler-private.h"
+
+#if CAIRO_HAS_PS_SURFACE  || \
+    CAIRO_HAS_PDF_SURFACE || \
+    CAIRO_HAS_SVG_SURFACE || \
+    CAIRO_HAS_WIN32_SURFACE
+#define CAIRO_HAS_FONT_SUBSET 1
+#endif
+
+#if CAIRO_HAS_PS_SURFACE || CAIRO_HAS_PDF_SURFACE
+#define CAIRO_HAS_PDF_OPERATORS 1
+#endif
+
+CAIRO_BEGIN_DECLS
+
+#ifdef _WIN32
+cairo_private FILE *
+_cairo_win32_tmpfile (void);
+#define tmpfile() _cairo_win32_tmpfile()
+#endif
+
+#undef MIN
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+
+#undef MAX
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
+
+#ifndef M_SQRT2
+#define M_SQRT2 1.41421356237309504880
+#endif
+
+#ifndef M_SQRT1_2
+#define M_SQRT1_2 0.707106781186547524400844362104849039
+#endif
+
+#undef  ARRAY_LENGTH
+#define ARRAY_LENGTH(__array) ((int) (sizeof (__array) / sizeof (__array[0])))
+
+
+/* This has to be updated whenever #cairo_status_t is extended.  That's
+ * a bit of a pain, but it should be easy to always catch as long as
+ * one adds a new test case to test a trigger of the new status value.
+ */
+#define CAIRO_STATUS_LAST_STATUS CAIRO_STATUS_INVALID_WEIGHT
+
+#ifdef __GNUC__
+#define cairo_container_of(ptr, type, member) ({ \
+    const typeof(((type *) 0)->member) *mptr__ = (ptr); \
+    (type *) ((char *) mptr__ - offsetof (type, member)); \
+})
+#else
+#define cairo_container_of(ptr, type, member) \
+    (type *)((char *) (ptr) - (char *) &((type *)0)->member)
+#endif
+
+
+/* Size in bytes of buffer to use off the stack per functions.
+ * Mostly used by text functions.  For larger allocations, they'll
+ * malloc(). */
+#ifndef CAIRO_STACK_BUFFER_SIZE
+#define CAIRO_STACK_BUFFER_SIZE (512 * sizeof (int))
+#endif
+
+#define CAIRO_STACK_ARRAY_LENGTH(T) (CAIRO_STACK_BUFFER_SIZE / sizeof(T))
+
+#define ASSERT_NOT_REACHED		\
+do {					\
+    static const int NOT_REACHED = 0;	\
+    assert (NOT_REACHED);		\
+} while (0)
+#define COMPILE_TIME_ASSERT1(condition, line)		\
+    typedef int compile_time_assertion_at_line_##line##_failed [(condition)?1:-1];
+#define COMPILE_TIME_ASSERT0(condition, line)	COMPILE_TIME_ASSERT1(condition, line)
+#define COMPILE_TIME_ASSERT(condition)		COMPILE_TIME_ASSERT0(condition, __LINE__)
+
+#define CAIRO_ALPHA_IS_OPAQUE(alpha) ((alpha) >= ((double)0xff00 / (double)0xffff))
+#define CAIRO_ALPHA_SHORT_IS_OPAQUE(alpha) ((alpha) >= 0xff00)
+#define CAIRO_ALPHA_IS_ZERO(alpha) ((alpha) <= 0.0)
+
+#define CAIRO_COLOR_IS_OPAQUE(color) CAIRO_ALPHA_SHORT_IS_OPAQUE ((color)->alpha_short)
+
+/* Reverse the bits in a byte with 7 operations (no 64-bit):
+ * Devised by Sean Anderson, July 13, 2001.
+ * Source: http://graphics.stanford.edu/~seander/bithacks.html#ReverseByteWith32Bits
+ */
+#define CAIRO_BITSWAP8(c) ((((c) * 0x0802LU & 0x22110LU) | ((c) * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16)
+
+/* Return the number of 1 bits in mask.
+ *
+ * GCC 3.4 supports a "population count" builtin, which on many targets is
+ * implemented with a single instruction. There is a fallback definition
+ * in libgcc in case a target does not have one, which should be just as
+ * good as the open-coded solution below, (which is "HACKMEM 169").
+ */
+static inline int
+_cairo_popcount (uint32_t mask)
+{
+#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+    return __builtin_popcount (mask);
+#else
+    register int y;
+
+    y = (mask >> 1) &033333333333;
+    y = mask - y - ((y >>1) & 033333333333);
+    return (((y + (y >> 3)) & 030707070707) % 077);
+#endif
+}
+
+#ifdef WORDS_BIGENDIAN
+#define CAIRO_BITSWAP8_IF_LITTLE_ENDIAN(c) (c)
+#else
+#define CAIRO_BITSWAP8_IF_LITTLE_ENDIAN(c) CAIRO_BITSWAP8(c)
+#endif
+
+#ifdef WORDS_BIGENDIAN
+
+#define cpu_to_be16(v) (v)
+#define be16_to_cpu(v) (v)
+#define cpu_to_be32(v) (v)
+#define be32_to_cpu(v) (v)
+
+#else
+
+static inline uint16_t
+cpu_to_be16(uint16_t v)
+{
+    return (v << 8) | (v >> 8);
+}
+
+static inline uint16_t
+be16_to_cpu(uint16_t v)
+{
+    return cpu_to_be16 (v);
+}
+
+static inline uint32_t
+cpu_to_be32(uint32_t v)
+{
+    return (cpu_to_be16 (v) << 16) | cpu_to_be16 (v >> 16);
+}
+
+static inline uint32_t
+be32_to_cpu(uint32_t v)
+{
+    return cpu_to_be32 (v);
+}
+
+#endif
+
+#include "cairo-types-private.h"
+#include "cairo-cache-private.h"
+#include "cairo-reference-count-private.h"
+
+cairo_private void
+_cairo_box_from_doubles (cairo_box_t *box,
+			 double *x1, double *y1,
+			 double *x2, double *y2);
+
+cairo_private void
+_cairo_box_to_doubles (const cairo_box_t *box,
+		       double *x1, double *y1,
+		       double *x2, double *y2);
+
+cairo_private void
+_cairo_box_from_rectangle (cairo_box_t                 *box,
+			   const cairo_rectangle_int_t *rectangle);
+
+cairo_private void
+_cairo_box_round_to_rectangle (const cairo_box_t     *box,
+			       cairo_rectangle_int_t *rectangle);
+
+cairo_private cairo_bool_t
+_cairo_rectangle_intersect (cairo_rectangle_int_t *dst,
+			    const cairo_rectangle_int_t *src);
+
+cairo_private cairo_bool_t
+_cairo_box_intersects_line_segment (cairo_box_t *box, cairo_line_t *line);
+
+cairo_private cairo_bool_t
+_cairo_box_contains_point (cairo_box_t *box, cairo_point_t *point);
+
+/* cairo-array.c structures and functions */
+
+cairo_private void
+_cairo_array_init (cairo_array_t *array, int element_size);
+
+cairo_private void
+_cairo_array_init_snapshot (cairo_array_t	*array,
+			    const cairo_array_t *other);
+
+cairo_private void
+_cairo_array_fini (cairo_array_t *array);
+
+cairo_private cairo_status_t
+_cairo_array_grow_by (cairo_array_t *array, unsigned int additional);
+
+cairo_private void
+_cairo_array_truncate (cairo_array_t *array, unsigned int num_elements);
+
+cairo_private cairo_status_t
+_cairo_array_append (cairo_array_t *array, const void *element);
+
+cairo_private cairo_status_t
+_cairo_array_append_multiple (cairo_array_t	*array,
+			      const void	*elements,
+			      int		 num_elements);
+
+cairo_private cairo_status_t
+_cairo_array_allocate (cairo_array_t	 *array,
+		       unsigned int	  num_elements,
+		       void		**elements);
+
+cairo_private void *
+_cairo_array_index (cairo_array_t *array, unsigned int index);
+
+cairo_private void
+_cairo_array_copy_element (cairo_array_t *array, int index, void *dst);
+
+cairo_private int
+_cairo_array_num_elements (cairo_array_t *array);
+
+cairo_private int
+_cairo_array_size (cairo_array_t *array);
+
+cairo_private void
+_cairo_user_data_array_init (cairo_user_data_array_t *array);
+
+cairo_private void
+_cairo_user_data_array_fini (cairo_user_data_array_t *array);
+
+cairo_private void *
+_cairo_user_data_array_get_data (cairo_user_data_array_t     *array,
+				 const cairo_user_data_key_t *key);
+
+cairo_private cairo_status_t
+_cairo_user_data_array_set_data (cairo_user_data_array_t     *array,
+				 const cairo_user_data_key_t *key,
+				 void			     *user_data,
+				 cairo_destroy_func_t	      destroy);
+
+cairo_private unsigned long
+_cairo_hash_string (const char *c);
+
+/*
+ * A #cairo_unscaled_font_t is just an opaque handle we use in the
+ * glyph cache.
+ */
+typedef struct _cairo_unscaled_font {
+    cairo_hash_entry_t			 hash_entry;
+    cairo_reference_count_t		 ref_count;
+    const cairo_unscaled_font_backend_t	*backend;
+} cairo_unscaled_font_t;
+
+typedef struct _cairo_scaled_glyph {
+    cairo_cache_entry_t	    cache_entry;	/* hash is glyph index */
+    cairo_scaled_font_t	    *scaled_font;	/* font the glyph lives in */
+    cairo_text_extents_t    metrics;		/* user-space metrics */
+    cairo_box_t		    bbox;		/* device-space bounds */
+    int16_t                 x_advance;		/* device-space rounded X advance */
+    int16_t                 y_advance;		/* device-space rounded Y advance */
+    cairo_image_surface_t   *surface;		/* device-space image */
+    cairo_path_fixed_t	    *path;		/* device-space outline */
+    cairo_surface_t         *meta_surface;	/* device-space meta-surface */
+    void		    *surface_private;	/* for the surface backend */
+} cairo_scaled_glyph_t;
+
+#define _cairo_scaled_glyph_index(g) ((g)->cache_entry.hash)
+#define _cairo_scaled_glyph_set_index(g,i)  ((g)->cache_entry.hash = (i))
+
+#include "cairo-scaled-font-private.h"
+
+struct _cairo_font_face {
+    /* hash_entry must be first */
+    cairo_hash_entry_t hash_entry;
+    cairo_status_t status;
+    cairo_reference_count_t ref_count;
+    cairo_user_data_array_t user_data;
+    const cairo_font_face_backend_t *backend;
+};
+
+cairo_private void
+_cairo_font_face_reset_static_data (void);
+
+cairo_private void
+_cairo_ft_font_reset_static_data (void);
+
+/* the font backend interface */
+
+struct _cairo_unscaled_font_backend {
+    void (*destroy)     	    (void		             *unscaled_font);
+};
+
+/* #cairo_toy_font_face_t - simple family/slant/weight font faces used for
+ * the built-in font API
+ */
+
+typedef struct _cairo_toy_font_face {
+    cairo_font_face_t base;
+    const char *family;
+    cairo_bool_t owns_family;
+    cairo_font_slant_t slant;
+    cairo_font_weight_t weight;
+} cairo_toy_font_face_t;
+
+typedef enum _cairo_scaled_glyph_info {
+    CAIRO_SCALED_GLYPH_INFO_METRICS	 = (1 << 0),
+    CAIRO_SCALED_GLYPH_INFO_SURFACE	 = (1 << 1),
+    CAIRO_SCALED_GLYPH_INFO_PATH	 = (1 << 2),
+    CAIRO_SCALED_GLYPH_INFO_META_SURFACE = (1 << 3)
+} cairo_scaled_glyph_info_t;
+
+typedef struct _cairo_scaled_font_subset {
+    cairo_scaled_font_t *scaled_font;
+    unsigned int font_id;
+    unsigned int subset_id;
+
+    /* Index of glyphs array is subset_glyph_index.
+     * Value of glyphs array is scaled_font_glyph_index.
+     */
+    unsigned long *glyphs;
+    unsigned long *to_unicode;
+    char          **utf8;
+    char          **glyph_names;
+    unsigned int num_glyphs;
+    cairo_bool_t is_composite;
+} cairo_scaled_font_subset_t;
+
+struct _cairo_scaled_font_backend {
+    cairo_font_type_t type;
+
+    cairo_warn cairo_status_t
+    (*get_implementation)  (cairo_toy_font_face_t	*toy_face,
+			    cairo_font_face_t	       **font_face);
+
+    cairo_warn cairo_status_t
+    (*create_toy)  (cairo_toy_font_face_t	*toy_face,
+		    const cairo_matrix_t	*font_matrix,
+		    const cairo_matrix_t	*ctm,
+		    const cairo_font_options_t	*options,
+		    cairo_scaled_font_t	       **scaled_font);
+
+    void
+    (*fini)		(void			*scaled_font);
+
+    cairo_warn cairo_int_status_t
+    (*scaled_glyph_init)	(void			     *scaled_font,
+				 cairo_scaled_glyph_t	     *scaled_glyph,
+				 cairo_scaled_glyph_info_t    info);
+
+    /* A backend only needs to implement this or ucs4_to_index(), not
+     * both. This allows the backend to do something more sophisticated
+     * then just converting characters one by one.
+     */
+    cairo_warn cairo_int_status_t
+    (*text_to_glyphs) (void                       *scaled_font,
+		       double		           x,
+		       double		           y,
+		       const char	          *utf8,
+		       int		           utf8_len,
+		       cairo_glyph_t	         **glyphs,
+		       int		          *num_glyphs,
+		       cairo_text_cluster_t      **clusters,
+		       int		          *num_clusters,
+		       cairo_text_cluster_flags_t *cluster_flags);
+
+    unsigned long
+    (*ucs4_to_index)		(void			     *scaled_font,
+				 uint32_t		      ucs4);
+    cairo_warn cairo_int_status_t
+    (*show_glyphs)	(void			*scaled_font,
+			 cairo_operator_t	 op,
+			 cairo_pattern_t	*pattern,
+			 cairo_surface_t	*surface,
+			 int			 source_x,
+			 int			 source_y,
+			 int			 dest_x,
+			 int			 dest_y,
+			 unsigned int		 width,
+			 unsigned int		 height,
+			 cairo_glyph_t		*glyphs,
+			 int			 num_glyphs,
+			 int			*remaining_glyphs);
+
+    cairo_warn cairo_int_status_t
+    (*load_truetype_table)(void		        *scaled_font,
+                           unsigned long         tag,
+                           long                  offset,
+                           unsigned char        *buffer,
+                           unsigned long        *length);
+
+    /* returns -1 if the unicode character could not be found for the glyph */
+    cairo_warn cairo_int_status_t
+    (*index_to_ucs4)(void                       *scaled_font,
+		     unsigned long               index,
+                     uint32_t                   *ucs4);
+};
+
+struct _cairo_font_face_backend {
+    cairo_font_type_t	type;
+
+    /* The destroy() function is allowed to resurrect the font face
+     * by re-referencing. This is needed for the FreeType backend.
+     */
+    void
+    (*destroy)     (void			*font_face);
+
+    cairo_warn cairo_status_t
+    (*get_implementation)  (void			*font_face,
+			    cairo_font_face_t	       **font_face_out);
+
+    cairo_warn cairo_status_t
+    (*scaled_font_create) (void				*font_face,
+			   const cairo_matrix_t		*font_matrix,
+			   const cairo_matrix_t		*ctm,
+			   const cairo_font_options_t	*options,
+			   cairo_scaled_font_t	       **scaled_font);
+};
+
+extern const cairo_private struct _cairo_scaled_font_backend _cairo_user_scaled_font_backend;
+
+/* concrete font backends */
+#if CAIRO_HAS_FT_FONT
+
+extern const cairo_private struct _cairo_scaled_font_backend _cairo_ft_scaled_font_backend;
+
+#endif
+
+#if CAIRO_HAS_WIN32_FONT
+
+extern const cairo_private struct _cairo_scaled_font_backend _cairo_win32_scaled_font_backend;
+
+#endif
+
+#if CAIRO_HAS_QUARTZ_FONT
+
+extern const cairo_private struct _cairo_scaled_font_backend _cairo_quartz_scaled_font_backend;
+
+#endif
+
+struct _cairo_surface_backend {
+    cairo_surface_type_t type;
+
+    cairo_surface_t *
+    (*create_similar)		(void			*surface,
+				 cairo_content_t	 content,
+				 int			 width,
+				 int			 height);
+
+    cairo_warn cairo_status_t
+    (*finish)			(void			*surface);
+
+    cairo_warn cairo_status_t
+    (*acquire_source_image)	(void                    *abstract_surface,
+				 cairo_image_surface_t  **image_out,
+				 void                   **image_extra);
+
+    void
+    (*release_source_image)	(void                   *abstract_surface,
+				 cairo_image_surface_t  *image,
+				 void                   *image_extra);
+
+    cairo_warn cairo_status_t
+    (*acquire_dest_image)       (void                    *abstract_surface,
+				 cairo_rectangle_int_t   *interest_rect,
+				 cairo_image_surface_t  **image_out,
+				 cairo_rectangle_int_t   *image_rect,
+				 void                   **image_extra);
+
+    void
+    (*release_dest_image)       (void                    *abstract_surface,
+				 cairo_rectangle_int_t   *interest_rect,
+				 cairo_image_surface_t   *image,
+				 cairo_rectangle_int_t   *image_rect,
+				 void                    *image_extra);
+
+    /* Create a new surface (@clone_out) with the following
+     * characteristics:
+     *
+     * 1. It is as compatible as possible with @surface (in terms of
+     *    efficiency)
+     *
+     * 2. It has the same contents as @src within the given rectangle.
+     *
+     * 3. The offset of the similar surface with respect to the original
+     *    surface is returned in the clone_offset vector.
+     *    - if you clone the entire surface, this vector is zero.
+     *    - if you clone (src_x, src_y)x(w, h) the vector is (src_x, src_y);
+     */
+    cairo_warn cairo_status_t
+    (*clone_similar)            (void                   *surface,
+				 cairo_surface_t        *src,
+				 int                     src_x,
+				 int                     src_y,
+				 int                     width,
+				 int                     height,
+				 int                    *clone_offset_x,
+				 int                    *clone_offset_y,
+				 cairo_surface_t       **clone_out);
+
+    /* XXX: dst should be the first argument for consistency */
+    cairo_warn cairo_int_status_t
+    (*composite)		(cairo_operator_t	 op,
+				 cairo_pattern_t       	*src,
+				 cairo_pattern_t	*mask,
+				 void			*dst,
+				 int			 src_x,
+				 int			 src_y,
+				 int			 mask_x,
+				 int			 mask_y,
+				 int			 dst_x,
+				 int			 dst_y,
+				 unsigned int		 width,
+				 unsigned int		 height);
+
+    cairo_warn cairo_int_status_t
+    (*fill_rectangles)		(void			 *surface,
+				 cairo_operator_t	  op,
+				 const cairo_color_t     *color,
+				 cairo_rectangle_int_t   *rects,
+				 int			  num_rects);
+
+    /* XXX: dst should be the first argument for consistency */
+    cairo_warn cairo_int_status_t
+    (*composite_trapezoids)	(cairo_operator_t	 op,
+				 cairo_pattern_t	*pattern,
+				 void			*dst,
+				 cairo_antialias_t	 antialias,
+				 int			 src_x,
+				 int			 src_y,
+				 int			 dst_x,
+				 int			 dst_y,
+				 unsigned int		 width,
+				 unsigned int		 height,
+				 cairo_trapezoid_t	*traps,
+				 int			 num_traps);
+
+    cairo_warn cairo_int_status_t
+    (*copy_page)		(void			*surface);
+
+    cairo_warn cairo_int_status_t
+    (*show_page)		(void			*surface);
+
+    /* Set given region as the clip region for the surface, replacing
+     * any previously set clip region.  Passing in a NULL region will
+     * clear the surface clip region.
+     *
+     * The surface is expected to store the clip region and clip all
+     * following drawing operations against it until the clip region
+     * is cleared of replaced by another clip region.
+     *
+     * Cairo will call this function whenever a clip path can be
+     * represented as a device pixel aligned set of rectangles.  When
+     * this is not possible, cairo will use mask surfaces for
+     * clipping.
+     */
+    cairo_warn cairo_int_status_t
+    (*set_clip_region)		(void			*surface,
+				 cairo_region_t		*region);
+
+    /* Intersect the given path against the clip path currently set in
+     * the surface, using the given fill_rule and tolerance, and set
+     * the result as the new clipping path for the surface.  Passing
+     * in a NULL path will clear the surface clipping path.
+     *
+     * The surface is expected to store the resulting clip path and
+     * clip all following drawing operations against it until the clip
+     * path cleared or intersected with a new path.
+     *
+     * If a surface implements this function, set_clip_region() will
+     * never be called and should not be implemented.  If this
+     * function is not implemented cairo will use set_clip_region()
+     * (if available) and mask surfaces for clipping.
+     */
+    cairo_warn cairo_int_status_t
+    (*intersect_clip_path)	(void			*dst,
+				 cairo_path_fixed_t	*path,
+				 cairo_fill_rule_t	fill_rule,
+				 double			tolerance,
+				 cairo_antialias_t	antialias);
+
+    /* Get the extents of the current surface. For many surface types
+     * this will be as simple as { x=0, y=0, width=surface->width,
+     * height=surface->height}.
+     *
+     * This function need not take account of any clipping from
+     * set_clip_region since the generic version of set_clip_region
+     * saves those, and the generic get_clip_extents will only call
+     * into the specific surface->get_extents if there is no current
+     * clip.
+     *
+     * If this function is not implemented, or if it returns
+     * %CAIRO_INT_STATUS_UNSUPPORTED, the surface is considered to be
+     * boundless and inifnite bounds are used for it.
+     */
+    cairo_warn cairo_int_status_t
+    (*get_extents)		(void			 *surface,
+				 cairo_rectangle_int_t   *extents);
+
+    /*
+     * This is an optional entry to let the surface manage its own glyph
+     * resources. If null, render against this surface, using image
+     * surfaces as glyphs.
+     */
+    cairo_warn cairo_int_status_t
+    (*old_show_glyphs)		(cairo_scaled_font_t	        *font,
+				 cairo_operator_t		 op,
+				 cairo_pattern_t		*pattern,
+				 void				*surface,
+				 int				 source_x,
+				 int				 source_y,
+				 int				 dest_x,
+				 int				 dest_y,
+				 unsigned int			 width,
+				 unsigned int			 height,
+				 cairo_glyph_t			*glyphs,
+				 int				 num_glyphs);
+
+    void
+    (*get_font_options)         (void                  *surface,
+				 cairo_font_options_t  *options);
+
+    cairo_warn cairo_status_t
+    (*flush)                    (void                  *surface);
+
+    cairo_warn cairo_status_t
+    (*mark_dirty_rectangle)     (void                  *surface,
+				 int                    x,
+				 int                    y,
+				 int                    width,
+				 int                    height);
+
+    void
+    (*scaled_font_fini)		(cairo_scaled_font_t   *scaled_font);
+
+    void
+    (*scaled_glyph_fini)	(cairo_scaled_glyph_t	*scaled_glyph,
+				 cairo_scaled_font_t	*scaled_font);
+
+    /* OK, I'm starting over somewhat by defining the 5 top-level
+     * drawing operators for the surface backend here with consistent
+     * naming and argument-order conventions. */
+    cairo_warn cairo_int_status_t
+    (*paint)			(void			*surface,
+				 cairo_operator_t	 op,
+				 cairo_pattern_t	*source);
+
+    cairo_warn cairo_int_status_t
+    (*mask)			(void			*surface,
+				 cairo_operator_t	 op,
+				 cairo_pattern_t	*source,
+				 cairo_pattern_t	*mask);
+
+    cairo_warn cairo_int_status_t
+    (*stroke)			(void			*surface,
+				 cairo_operator_t	 op,
+				 cairo_pattern_t	*source,
+				 cairo_path_fixed_t	*path,
+				 cairo_stroke_style_t	*style,
+				 cairo_matrix_t		*ctm,
+				 cairo_matrix_t		*ctm_inverse,
+				 double			 tolerance,
+				 cairo_antialias_t	 antialias);
+
+    cairo_warn cairo_int_status_t
+    (*fill)			(void			*surface,
+				 cairo_operator_t	 op,
+				 cairo_pattern_t	*source,
+				 cairo_path_fixed_t	*path,
+				 cairo_fill_rule_t	 fill_rule,
+				 double			 tolerance,
+				 cairo_antialias_t	 antialias);
+
+    cairo_warn cairo_int_status_t
+    (*show_glyphs)		(void			*surface,
+				 cairo_operator_t	 op,
+				 cairo_pattern_t	*source,
+				 cairo_glyph_t		*glyphs,
+				 int			 num_glyphs,
+				 cairo_scaled_font_t	*scaled_font,
+				 int			*remaining_glyphs);
+
+    cairo_surface_t *
+    (*snapshot)			(void			*surface);
+
+    cairo_bool_t
+    (*is_similar)		(void			*surface_a,
+	                         void			*surface_b,
+				 cairo_content_t         content);
+
+    cairo_warn cairo_status_t
+    (*reset)			(void			*surface);
+
+    cairo_warn cairo_int_status_t
+    (*fill_stroke)		(void			*surface,
+				 cairo_operator_t	 fill_op,
+				 cairo_pattern_t	*fill_source,
+				 cairo_fill_rule_t	 fill_rule,
+				 double			 fill_tolerance,
+				 cairo_antialias_t	 fill_antialias,
+				 cairo_path_fixed_t	*path,
+				 cairo_operator_t	 stroke_op,
+				 cairo_pattern_t	*stroke_source,
+				 cairo_stroke_style_t	*stroke_style,
+				 cairo_matrix_t		*stroke_ctm,
+				 cairo_matrix_t		*stroke_ctm_inverse,
+				 double			 stroke_tolerance,
+				 cairo_antialias_t	 stroke_antialias);
+
+    cairo_surface_t *
+    (*create_solid_pattern_surface)
+			        (void			*surface,
+				 cairo_solid_pattern_t  *solid_pattern);
+
+    cairo_bool_t
+    (*has_show_text_glyphs)	(void			    *surface);
+
+    cairo_warn cairo_int_status_t
+    (*show_text_glyphs)		(void			    *surface,
+				 cairo_operator_t	     op,
+				 cairo_pattern_t	    *source,
+				 const char		    *utf8,
+				 int			     utf8_len,
+				 cairo_glyph_t		    *glyphs,
+				 int			     num_glyphs,
+				 const cairo_text_cluster_t *clusters,
+				 int			     num_clusters,
+				 cairo_text_cluster_flags_t  cluster_flags,
+				 cairo_scaled_font_t	    *scaled_font);
+};
+
+#include "cairo-surface-private.h"
+
+struct _cairo_image_surface {
+    cairo_surface_t base;
+
+    pixman_format_code_t pixman_format;
+    cairo_format_t format;
+    unsigned char *data;
+    cairo_bool_t owns_data;
+    cairo_bool_t has_clip;
+    cairo_image_transparency_t transparency;
+
+    int width;
+    int height;
+    int stride;
+    int depth;
+
+    pixman_image_t *pixman_image;
+};
+
+extern const cairo_private cairo_surface_backend_t _cairo_image_surface_backend;
+
+#define CAIRO_EXTEND_SURFACE_DEFAULT CAIRO_EXTEND_NONE
+#define CAIRO_EXTEND_GRADIENT_DEFAULT CAIRO_EXTEND_PAD
+#define CAIRO_FILTER_DEFAULT CAIRO_FILTER_GOOD
+
+struct _cairo_pattern {
+    cairo_pattern_type_t	type;
+    cairo_reference_count_t	ref_count;
+    cairo_status_t		status;
+    cairo_user_data_array_t	user_data;
+
+    cairo_matrix_t		matrix;
+    cairo_filter_t		filter;
+    cairo_extend_t		extend;
+};
+
+struct _cairo_solid_pattern {
+    cairo_pattern_t base;
+    cairo_color_t color;
+    cairo_content_t content;
+};
+
+extern const cairo_private cairo_solid_pattern_t _cairo_pattern_nil;
+extern const cairo_private cairo_solid_pattern_t _cairo_pattern_none;
+
+typedef struct _cairo_surface_pattern {
+    cairo_pattern_t base;
+
+    cairo_surface_t *surface;
+} cairo_surface_pattern_t;
+
+typedef struct _cairo_gradient_stop {
+    double offset;
+    cairo_color_t color;
+} cairo_gradient_stop_t;
+
+typedef struct _cairo_gradient_pattern {
+    cairo_pattern_t base;
+
+    unsigned int	    n_stops;
+    unsigned int	    stops_size;
+    cairo_gradient_stop_t  *stops;
+    cairo_gradient_stop_t   stops_embedded[2];
+} cairo_gradient_pattern_t;
+
+typedef struct _cairo_linear_pattern {
+    cairo_gradient_pattern_t base;
+
+    cairo_point_t p1;
+    cairo_point_t p2;
+} cairo_linear_pattern_t;
+
+typedef struct _cairo_radial_pattern {
+    cairo_gradient_pattern_t base;
+
+    cairo_point_t c1;
+    cairo_fixed_t r1;
+    cairo_point_t c2;
+    cairo_fixed_t r2;
+} cairo_radial_pattern_t;
+
+typedef union {
+    cairo_gradient_pattern_t base;
+
+    cairo_linear_pattern_t linear;
+    cairo_radial_pattern_t radial;
+} cairo_gradient_pattern_union_t;
+
+typedef union {
+    cairo_pattern_t base;
+
+    cairo_solid_pattern_t	   solid;
+    cairo_surface_pattern_t	   surface;
+    cairo_gradient_pattern_union_t gradient;
+} cairo_pattern_union_t;
+
+typedef struct _cairo_surface_attributes {
+    cairo_matrix_t matrix;
+    cairo_extend_t extend;
+    cairo_filter_t filter;
+    int		   x_offset;
+    int		   y_offset;
+    cairo_bool_t   acquired;
+    void	   *extra;
+} cairo_surface_attributes_t;
+
+typedef struct _cairo_traps {
+    cairo_status_t status;
+
+    cairo_box_t extents;
+
+    int num_traps;
+    int traps_size;
+    cairo_trapezoid_t *traps;
+    cairo_trapezoid_t  traps_embedded[1];
+
+    cairo_bool_t has_limits;
+    cairo_box_t limits;
+} cairo_traps_t;
+
+#define CAIRO_FONT_SLANT_DEFAULT   CAIRO_FONT_SLANT_NORMAL
+#define CAIRO_FONT_WEIGHT_DEFAULT  CAIRO_FONT_WEIGHT_NORMAL
+
+#define CAIRO_WIN32_FONT_FAMILY_DEFAULT "Arial"
+#define CAIRO_QUARTZ_FONT_FAMILY_DEFAULT  "Helvetica"
+#define CAIRO_FT_FONT_FAMILY_DEFAULT     ""
+
+#if   CAIRO_HAS_WIN32_FONT
+
+#define CAIRO_FONT_FAMILY_DEFAULT CAIRO_WIN32_FONT_FAMILY_DEFAULT
+#define CAIRO_SCALED_FONT_BACKEND_DEFAULT &_cairo_win32_scaled_font_backend
+
+#elif CAIRO_HAS_QUARTZ_FONT
+
+#define CAIRO_FONT_FAMILY_DEFAULT CAIRO_QUARTZ_FONT_FAMILY_DEFAULT
+#define CAIRO_SCALED_FONT_BACKEND_DEFAULT &_cairo_quartz_scaled_font_backend
+
+#elif CAIRO_HAS_FT_FONT
+
+#define CAIRO_FONT_FAMILY_DEFAULT CAIRO_FT_FONT_FAMILY_DEFAULT
+#define CAIRO_SCALED_FONT_BACKEND_DEFAULT &_cairo_ft_scaled_font_backend
+
+#else
+
+#define CAIRO_FONT_FAMILY_DEFAULT CAIRO_FT_FONT_FAMILY_DEFAULT
+#define CAIRO_SCALED_FONT_BACKEND_DEFAULT &_cairo_user_scaled_font_backend
+
+#endif
+
+#define CAIRO_GSTATE_OPERATOR_DEFAULT	CAIRO_OPERATOR_OVER
+#define CAIRO_GSTATE_TOLERANCE_DEFAULT	0.1
+#define CAIRO_GSTATE_FILL_RULE_DEFAULT	CAIRO_FILL_RULE_WINDING
+#define CAIRO_GSTATE_LINE_WIDTH_DEFAULT	2.0
+#define CAIRO_GSTATE_LINE_CAP_DEFAULT	CAIRO_LINE_CAP_BUTT
+#define CAIRO_GSTATE_LINE_JOIN_DEFAULT	CAIRO_LINE_JOIN_MITER
+#define CAIRO_GSTATE_MITER_LIMIT_DEFAULT	10.0
+#define CAIRO_GSTATE_DEFAULT_FONT_SIZE  10.0
+
+#define CAIRO_SURFACE_RESOLUTION_DEFAULT 72.0
+#define CAIRO_SURFACE_FALLBACK_RESOLUTION_DEFAULT 300.0
+
+typedef struct _cairo_stroke_face {
+    cairo_point_t ccw;
+    cairo_point_t point;
+    cairo_point_t cw;
+    cairo_slope_t dev_vector;
+    cairo_point_double_t usr_vector;
+} cairo_stroke_face_t;
+
+/* cairo.c */
+cairo_private void
+_cairo_restrict_value (double *value, double min, double max);
+
+cairo_private int
+_cairo_lround (double d);
+
+/* cairo-gstate.c */
+cairo_private cairo_status_t
+_cairo_gstate_init (cairo_gstate_t  *gstate,
+		    cairo_surface_t *target);
+
+cairo_private void
+_cairo_gstate_fini (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_save (cairo_gstate_t **gstate, cairo_gstate_t **freelist);
+
+cairo_private cairo_status_t
+_cairo_gstate_restore (cairo_gstate_t **gstate, cairo_gstate_t **freelist);
+
+cairo_private cairo_bool_t
+_cairo_gstate_is_redirected (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child);
+
+cairo_private cairo_surface_t *
+_cairo_gstate_get_target (cairo_gstate_t *gstate);
+
+cairo_private cairo_surface_t *
+_cairo_gstate_get_parent_target (cairo_gstate_t *gstate);
+
+cairo_private cairo_surface_t *
+_cairo_gstate_get_original_target (cairo_gstate_t *gstate);
+
+cairo_private cairo_clip_t *
+_cairo_gstate_get_clip (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_source (cairo_gstate_t *gstate, cairo_pattern_t *source);
+
+cairo_private cairo_pattern_t *
+_cairo_gstate_get_source (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_operator (cairo_gstate_t *gstate, cairo_operator_t op);
+
+cairo_private cairo_operator_t
+_cairo_gstate_get_operator (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_tolerance (cairo_gstate_t *gstate, double tolerance);
+
+cairo_private double
+_cairo_gstate_get_tolerance (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_fill_rule (cairo_gstate_t *gstate, cairo_fill_rule_t fill_rule);
+
+cairo_private cairo_fill_rule_t
+_cairo_gstate_get_fill_rule (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_line_width (cairo_gstate_t *gstate, double width);
+
+cairo_private double
+_cairo_gstate_get_line_width (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_line_cap (cairo_gstate_t *gstate, cairo_line_cap_t line_cap);
+
+cairo_private cairo_line_cap_t
+_cairo_gstate_get_line_cap (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_line_join (cairo_gstate_t *gstate, cairo_line_join_t line_join);
+
+cairo_private cairo_line_join_t
+_cairo_gstate_get_line_join (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_dash (cairo_gstate_t *gstate, const double *dash, int num_dashes, double offset);
+
+cairo_private void
+_cairo_gstate_get_dash (cairo_gstate_t *gstate, double *dash, int *num_dashes, double *offset);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_miter_limit (cairo_gstate_t *gstate, double limit);
+
+cairo_private double
+_cairo_gstate_get_miter_limit (cairo_gstate_t *gstate);
+
+cairo_private void
+_cairo_gstate_get_matrix (cairo_gstate_t *gstate, cairo_matrix_t *matrix);
+
+cairo_private cairo_status_t
+_cairo_gstate_translate (cairo_gstate_t *gstate, double tx, double ty);
+
+cairo_private cairo_status_t
+_cairo_gstate_scale (cairo_gstate_t *gstate, double sx, double sy);
+
+cairo_private cairo_status_t
+_cairo_gstate_rotate (cairo_gstate_t *gstate, double angle);
+
+cairo_private cairo_status_t
+_cairo_gstate_transform (cairo_gstate_t	      *gstate,
+			 const cairo_matrix_t *matrix);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_matrix (cairo_gstate_t       *gstate,
+			  const cairo_matrix_t *matrix);
+
+cairo_private void
+_cairo_gstate_identity_matrix (cairo_gstate_t *gstate);
+
+cairo_private void
+_cairo_gstate_user_to_device (cairo_gstate_t *gstate, double *x, double *y);
+
+cairo_private void
+_cairo_gstate_user_to_device_distance (cairo_gstate_t *gstate, double *dx, double *dy);
+
+cairo_private void
+_cairo_gstate_device_to_user (cairo_gstate_t *gstate, double *x, double *y);
+
+cairo_private void
+_cairo_gstate_device_to_user_distance (cairo_gstate_t *gstate, double *dx, double *dy);
+
+cairo_private void
+_cairo_gstate_user_to_backend (cairo_gstate_t *gstate, double *x, double *y);
+
+cairo_private void
+_cairo_gstate_backend_to_user (cairo_gstate_t *gstate, double *x, double *y);
+
+cairo_private void
+_cairo_gstate_backend_to_user_rectangle (cairo_gstate_t *gstate,
+                                         double *x1, double *y1,
+                                         double *x2, double *y2,
+                                         cairo_bool_t *is_tight);
+
+cairo_private cairo_status_t
+_cairo_gstate_path_extents (cairo_gstate_t     *gstate,
+			    cairo_path_fixed_t *path,
+			    double *x1, double *y1,
+			    double *x2, double *y2);
+
+cairo_private cairo_status_t
+_cairo_gstate_paint (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_mask (cairo_gstate_t  *gstate,
+		    cairo_pattern_t *mask);
+
+cairo_private cairo_status_t
+_cairo_gstate_stroke (cairo_gstate_t *gstate, cairo_path_fixed_t *path);
+
+cairo_private cairo_status_t
+_cairo_gstate_fill (cairo_gstate_t *gstate, cairo_path_fixed_t *path);
+
+cairo_private cairo_status_t
+_cairo_gstate_copy_page (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_show_page (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_stroke_extents (cairo_gstate_t	 *gstate,
+			      cairo_path_fixed_t *path,
+                              double *x1, double *y1,
+			      double *x2, double *y2);
+
+cairo_private cairo_status_t
+_cairo_gstate_fill_extents (cairo_gstate_t     *gstate,
+			    cairo_path_fixed_t *path,
+                            double *x1, double *y1,
+			    double *x2, double *y2);
+
+cairo_private cairo_status_t
+_cairo_gstate_in_stroke (cairo_gstate_t	    *gstate,
+			 cairo_path_fixed_t *path,
+			 double		     x,
+			 double		     y,
+			 cairo_bool_t	    *inside_ret);
+
+cairo_private cairo_status_t
+_cairo_gstate_in_fill (cairo_gstate_t	  *gstate,
+		       cairo_path_fixed_t *path,
+		       double		   x,
+		       double		   y,
+		       cairo_bool_t	  *inside_ret);
+
+cairo_private cairo_status_t
+_cairo_gstate_clip (cairo_gstate_t *gstate, cairo_path_fixed_t *path);
+
+cairo_private cairo_status_t
+_cairo_gstate_reset_clip (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_clip_extents (cairo_gstate_t *gstate,
+		            double         *x1,
+		            double         *y1,
+        		    double         *x2,
+        		    double         *y2);
+
+cairo_private cairo_rectangle_list_t*
+_cairo_gstate_copy_clip_rectangle_list (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_show_surface (cairo_gstate_t	*gstate,
+			    cairo_surface_t	*surface,
+			    double		 x,
+			    double		 y,
+			    double		width,
+			    double		height);
+
+cairo_private cairo_status_t
+_cairo_gstate_select_font_face (cairo_gstate_t *gstate,
+				const char *family,
+				cairo_font_slant_t slant,
+				cairo_font_weight_t weight);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_font_size (cairo_gstate_t *gstate,
+			     double          size);
+
+cairo_private void
+_cairo_gstate_get_font_matrix (cairo_gstate_t *gstate,
+			       cairo_matrix_t *matrix);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_font_matrix (cairo_gstate_t	    *gstate,
+			       const cairo_matrix_t *matrix);
+
+cairo_private void
+_cairo_gstate_get_font_options (cairo_gstate_t       *gstate,
+				cairo_font_options_t *options);
+
+cairo_private void
+_cairo_gstate_set_font_options (cairo_gstate_t	           *gstate,
+				const cairo_font_options_t *options);
+
+cairo_private cairo_status_t
+_cairo_gstate_get_font_face (cairo_gstate_t     *gstate,
+			     cairo_font_face_t **font_face);
+
+cairo_private cairo_status_t
+_cairo_gstate_get_scaled_font (cairo_gstate_t       *gstate,
+			       cairo_scaled_font_t **scaled_font);
+
+cairo_private cairo_status_t
+_cairo_gstate_get_font_extents (cairo_gstate_t *gstate,
+				cairo_font_extents_t *extents);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_font_face (cairo_gstate_t    *gstate,
+			     cairo_font_face_t *font_face);
+
+cairo_private cairo_status_t
+_cairo_gstate_text_to_glyphs (cairo_gstate_t	         *gstate,
+			      double		          x,
+			      double		          y,
+			      const char	         *utf8,
+			      int		          utf8_len,
+			      cairo_glyph_t	        **glyphs,
+			      int		         *num_glyphs,
+			      cairo_text_cluster_t      **clusters,
+			      int		         *num_clusters,
+			      cairo_text_cluster_flags_t *cluster_flags);
+
+cairo_private cairo_status_t
+_cairo_gstate_glyph_extents (cairo_gstate_t *gstate,
+			     const cairo_glyph_t *glyphs,
+			     int num_glyphs,
+			     cairo_text_extents_t *extents);
+
+cairo_private cairo_status_t
+_cairo_gstate_show_text_glyphs (cairo_gstate_t		   *gstate,
+				const char		   *utf8,
+				int			    utf8_len,
+				const cairo_glyph_t	   *glyphs,
+				int			    num_glyphs,
+				const cairo_text_cluster_t *clusters,
+				int			    num_clusters,
+			        cairo_text_cluster_flags_t  cluster_flags);
+
+cairo_private cairo_status_t
+_cairo_gstate_glyph_path (cairo_gstate_t      *gstate,
+			  const cairo_glyph_t *glyphs,
+			  int		       num_glyphs,
+			  cairo_path_fixed_t  *path);
+
+cairo_private cairo_bool_t
+_cairo_operator_bounded_by_mask (cairo_operator_t op);
+
+cairo_private cairo_bool_t
+_cairo_operator_bounded_by_source (cairo_operator_t op);
+
+/* cairo-color.c */
+cairo_private const cairo_color_t *
+_cairo_stock_color (cairo_stock_t stock);
+
+#define CAIRO_COLOR_WHITE       _cairo_stock_color (CAIRO_STOCK_WHITE)
+#define CAIRO_COLOR_BLACK       _cairo_stock_color (CAIRO_STOCK_BLACK)
+#define CAIRO_COLOR_TRANSPARENT _cairo_stock_color (CAIRO_STOCK_TRANSPARENT)
+
+cairo_private uint16_t
+_cairo_color_double_to_short (double d);
+
+cairo_private void
+_cairo_color_init (cairo_color_t *color);
+
+cairo_private void
+_cairo_color_init_rgb (cairo_color_t *color,
+		       double red, double green, double blue);
+
+cairo_private void
+_cairo_color_init_rgba (cairo_color_t *color,
+			double red, double green, double blue,
+			double alpha);
+
+cairo_private void
+_cairo_color_multiply_alpha (cairo_color_t *color,
+			     double	    alpha);
+
+cairo_private void
+_cairo_color_get_rgba (cairo_color_t *color,
+		       double	     *red,
+		       double	     *green,
+		       double	     *blue,
+		       double	     *alpha);
+
+cairo_private void
+_cairo_color_get_rgba_premultiplied (cairo_color_t *color,
+				     double	   *red,
+				     double	   *green,
+				     double	   *blue,
+				     double	   *alpha);
+
+cairo_private cairo_bool_t
+_cairo_color_equal (const cairo_color_t *color_a,
+                    const cairo_color_t *color_b);
+
+/* cairo-font-face.c */
+
+extern const cairo_private cairo_toy_font_face_t _cairo_font_face_nil;
+
+cairo_private void
+_cairo_font_face_init (cairo_font_face_t               *font_face,
+		       const cairo_font_face_backend_t *backend);
+
+cairo_private cairo_status_t
+_cairo_font_face_set_error (cairo_font_face_t *font_face,
+	                    cairo_status_t     status);
+
+cairo_private void
+_cairo_unscaled_font_init (cairo_unscaled_font_t               *font,
+			   const cairo_unscaled_font_backend_t *backend);
+
+cairo_private_no_warn cairo_unscaled_font_t *
+_cairo_unscaled_font_reference (cairo_unscaled_font_t *font);
+
+cairo_private void
+_cairo_unscaled_font_destroy (cairo_unscaled_font_t *font);
+
+/* cairo-font-face-twin.c */
+
+cairo_private cairo_font_face_t *
+_cairo_font_face_twin_create (cairo_font_slant_t slant,
+			      cairo_font_weight_t weight);
+
+/* cairo-font-face-twin-data.c */
+
+extern const cairo_private int8_t _cairo_twin_outlines[];
+extern const cairo_private uint16_t _cairo_twin_charmap[128];
+
+/* cairo-font-options.c */
+
+cairo_private void
+_cairo_font_options_init_default (cairo_font_options_t *options);
+
+cairo_private void
+_cairo_font_options_init_copy (cairo_font_options_t		*options,
+			       const cairo_font_options_t	*other);
+
+/* cairo-hull.c */
+cairo_private cairo_status_t
+_cairo_hull_compute (cairo_pen_vertex_t *vertices, int *num_vertices);
+
+/* cairo-lzw.c */
+cairo_private unsigned char *
+_cairo_lzw_compress (unsigned char *data, unsigned long *size_in_out);
+
+/* cairo-misc.c */
+cairo_private cairo_status_t
+_cairo_validate_text_clusters (const char		   *utf8,
+			       int			    utf8_len,
+			       const cairo_glyph_t	   *glyphs,
+			       int			    num_glyphs,
+			       const cairo_text_cluster_t  *clusters,
+			       int			    num_clusters,
+			       cairo_text_cluster_flags_t   cluster_flags);
+
+/* cairo-path-fixed.c */
+cairo_private void
+_cairo_path_fixed_init (cairo_path_fixed_t *path);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_init_copy (cairo_path_fixed_t *path,
+			     cairo_path_fixed_t *other);
+
+cairo_private cairo_bool_t
+_cairo_path_fixed_is_equal (cairo_path_fixed_t *path,
+			    cairo_path_fixed_t *other);
+
+cairo_private cairo_path_fixed_t *
+_cairo_path_fixed_create (void);
+
+cairo_private void
+_cairo_path_fixed_fini (cairo_path_fixed_t *path);
+
+cairo_private void
+_cairo_path_fixed_destroy (cairo_path_fixed_t *path);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_move_to (cairo_path_fixed_t  *path,
+			   cairo_fixed_t	x,
+			   cairo_fixed_t	y);
+
+cairo_private void
+_cairo_path_fixed_new_sub_path (cairo_path_fixed_t *path);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_rel_move_to (cairo_path_fixed_t *path,
+			       cairo_fixed_t	   dx,
+			       cairo_fixed_t	   dy);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_line_to (cairo_path_fixed_t *path,
+			   cairo_fixed_t	x,
+			   cairo_fixed_t	y);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_rel_line_to (cairo_path_fixed_t *path,
+			       cairo_fixed_t	   dx,
+			       cairo_fixed_t	   dy);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_curve_to (cairo_path_fixed_t	*path,
+			    cairo_fixed_t x0, cairo_fixed_t y0,
+			    cairo_fixed_t x1, cairo_fixed_t y1,
+			    cairo_fixed_t x2, cairo_fixed_t y2);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_rel_curve_to (cairo_path_fixed_t *path,
+				cairo_fixed_t dx0, cairo_fixed_t dy0,
+				cairo_fixed_t dx1, cairo_fixed_t dy1,
+				cairo_fixed_t dx2, cairo_fixed_t dy2);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_close_path (cairo_path_fixed_t *path);
+
+cairo_private cairo_bool_t
+_cairo_path_fixed_get_current_point (cairo_path_fixed_t *path,
+				     cairo_fixed_t	*x,
+				     cairo_fixed_t	*y);
+
+typedef cairo_status_t
+(cairo_path_fixed_move_to_func_t) (void		 *closure,
+				   cairo_point_t *point);
+
+typedef cairo_status_t
+(cairo_path_fixed_line_to_func_t) (void		 *closure,
+				   cairo_point_t *point);
+
+typedef cairo_status_t
+(cairo_path_fixed_curve_to_func_t) (void	  *closure,
+				    cairo_point_t *p0,
+				    cairo_point_t *p1,
+				    cairo_point_t *p2);
+
+typedef cairo_status_t
+(cairo_path_fixed_close_path_func_t) (void *closure);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_interpret (const cairo_path_fixed_t	  *path,
+		       cairo_direction_t		   dir,
+		       cairo_path_fixed_move_to_func_t	  *move_to,
+		       cairo_path_fixed_line_to_func_t	  *line_to,
+		       cairo_path_fixed_curve_to_func_t	  *curve_to,
+		       cairo_path_fixed_close_path_func_t *close_path,
+		       void				  *closure);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_interpret_flat (const cairo_path_fixed_t *path,
+		       cairo_direction_t		   dir,
+		       cairo_path_fixed_move_to_func_t	  *move_to,
+		       cairo_path_fixed_line_to_func_t	  *line_to,
+		       cairo_path_fixed_close_path_func_t *close_path,
+		       void				  *closure,
+		       double				  tolerance);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_append (cairo_path_fixed_t		  *path,
+			  const cairo_path_fixed_t	  *other,
+			  cairo_direction_t		   dir);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_bounds (cairo_path_fixed_t *path,
+			  double *x1, double *y1,
+			  double *x2, double *y2,
+			  double tolerance);
+
+cairo_private void
+_cairo_path_fixed_transform (cairo_path_fixed_t	*path,
+			     cairo_matrix_t	*matrix);
+
+cairo_private cairo_bool_t
+_cairo_path_fixed_is_empty (cairo_path_fixed_t *path);
+
+cairo_private cairo_bool_t
+_cairo_path_fixed_is_box (cairo_path_fixed_t *path,
+                          cairo_box_t *box);
+
+cairo_private cairo_bool_t
+_cairo_path_fixed_is_rectangle (cairo_path_fixed_t *path,
+				cairo_box_t        *box);
+
+/* cairo-path-fill.c */
+cairo_private cairo_status_t
+_cairo_path_fixed_fill_to_traps (cairo_path_fixed_t *path,
+				 cairo_fill_rule_t   fill_rule,
+				 double              tolerance,
+				 cairo_traps_t      *traps);
+
+/* cairo-path-stroke.c */
+cairo_private cairo_status_t
+_cairo_path_fixed_stroke_to_traps (cairo_path_fixed_t	*path,
+				   cairo_stroke_style_t	*stroke_style,
+				   cairo_matrix_t	*ctm,
+				   cairo_matrix_t	*ctm_inverse,
+				   double		 tolerance,
+				   cairo_traps_t	*traps);
+
+/* cairo-scaled-font.c */
+
+cairo_private void
+_cairo_scaled_font_freeze_cache (cairo_scaled_font_t *scaled_font);
+
+cairo_private void
+_cairo_scaled_font_thaw_cache (cairo_scaled_font_t *scaled_font);
+
+cairo_private void
+_cairo_scaled_font_reset_cache (cairo_scaled_font_t *scaled_font);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_set_error (cairo_scaled_font_t *scaled_font,
+			      cairo_status_t status);
+
+cairo_private cairo_scaled_font_t *
+_cairo_scaled_font_create_in_error (cairo_status_t status);
+
+cairo_private void
+_cairo_scaled_font_reset_static_data (void);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_register_placeholder_and_unlock_font_map (cairo_scaled_font_t *scaled_font);
+
+cairo_private void
+_cairo_scaled_font_unregister_placeholder_and_lock_font_map (cairo_scaled_font_t *scaled_font);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
+			 cairo_font_face_t		   *font_face,
+			 const cairo_matrix_t              *font_matrix,
+			 const cairo_matrix_t              *ctm,
+			 const cairo_font_options_t	   *options,
+			 const cairo_scaled_font_backend_t *backend);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
+				cairo_font_extents_t	    *fs_metrics);
+
+/* This should only be called on an error path by a scaled_font constructor */
+cairo_private void
+_cairo_scaled_font_fini (cairo_scaled_font_t *scaled_font);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_font_extents (cairo_scaled_font_t  *scaled_font,
+				 cairo_font_extents_t *extents);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_glyph_device_extents (cairo_scaled_font_t	 *scaled_font,
+					 const cairo_glyph_t	 *glyphs,
+					 int                      num_glyphs,
+					 cairo_rectangle_int_t   *extents);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_show_glyphs (cairo_scaled_font_t *scaled_font,
+				cairo_operator_t     op,
+				cairo_pattern_t	    *source,
+				cairo_surface_t	    *surface,
+				int		     source_x,
+				int		     source_y,
+				int		     dest_x,
+				int		     dest_y,
+				unsigned int	     width,
+				unsigned int	     height,
+				cairo_glyph_t	    *glyphs,
+				int		     num_glyphs);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_glyph_path (cairo_scaled_font_t *scaled_font,
+			       const cairo_glyph_t *glyphs,
+			       int                  num_glyphs,
+			       cairo_path_fixed_t  *path);
+
+cairo_private void
+_cairo_scaled_glyph_set_metrics (cairo_scaled_glyph_t *scaled_glyph,
+				 cairo_scaled_font_t *scaled_font,
+				 cairo_text_extents_t *fs_metrics);
+
+cairo_private void
+_cairo_scaled_glyph_set_surface (cairo_scaled_glyph_t *scaled_glyph,
+				 cairo_scaled_font_t *scaled_font,
+				 cairo_image_surface_t *surface);
+
+cairo_private void
+_cairo_scaled_glyph_set_path (cairo_scaled_glyph_t *scaled_glyph,
+			      cairo_scaled_font_t *scaled_font,
+			      cairo_path_fixed_t *path);
+
+cairo_private void
+_cairo_scaled_glyph_set_meta_surface (cairo_scaled_glyph_t *scaled_glyph,
+				      cairo_scaled_font_t *scaled_font,
+				      cairo_surface_t *meta_surface);
+
+cairo_private cairo_int_status_t
+_cairo_scaled_glyph_lookup (cairo_scaled_font_t *scaled_font,
+			    unsigned long index,
+			    cairo_scaled_glyph_info_t info,
+			    cairo_scaled_glyph_t **scaled_glyph_ret);
+
+cairo_private double
+_cairo_scaled_font_get_max_scale (cairo_scaled_font_t *scaled_font);
+
+cairo_private void
+_cairo_scaled_font_map_destroy (void);
+
+/* cairo-stroke-style.c */
+
+cairo_private void
+_cairo_stroke_style_init (cairo_stroke_style_t *style);
+
+cairo_private cairo_status_t
+_cairo_stroke_style_init_copy (cairo_stroke_style_t *style,
+			       cairo_stroke_style_t *other);
+
+cairo_private void
+_cairo_stroke_style_fini (cairo_stroke_style_t *style);
+
+cairo_private void
+_cairo_stroke_style_max_distance_from_path (const cairo_stroke_style_t *style,
+                                            const cairo_matrix_t *ctm,
+                                            double *dx, double *dy);
+
+/* cairo-surface.c */
+
+cairo_private cairo_surface_t *
+_cairo_surface_create_in_error (cairo_status_t status);
+
+cairo_private cairo_status_t
+_cairo_surface_set_error (cairo_surface_t	*surface,
+			  cairo_status_t	 status);
+
+cairo_private void
+_cairo_surface_set_resolution (cairo_surface_t *surface,
+                               double x_res,
+                               double y_res);
+
+cairo_private cairo_surface_t *
+_cairo_surface_create_similar_scratch (cairo_surface_t *other,
+				       cairo_content_t	content,
+				       int		width,
+				       int		height);
+
+cairo_private cairo_surface_t *
+_cairo_surface_create_similar_solid (cairo_surface_t	 *other,
+				     cairo_content_t	  content,
+				     int		  width,
+				     int		  height,
+				     const cairo_color_t *color);
+
+cairo_private cairo_surface_t *
+_cairo_surface_create_solid_pattern_surface (cairo_surface_t	   *other,
+					     cairo_solid_pattern_t *solid_pattern);
+
+cairo_private cairo_int_status_t
+_cairo_surface_repaint_solid_pattern_surface (cairo_surface_t	    *other,
+					      cairo_surface_t       *solid_surface,
+					      cairo_solid_pattern_t *solid_pattern);
+
+cairo_private void
+_cairo_surface_init (cairo_surface_t			*surface,
+		     const cairo_surface_backend_t	*backend,
+		     cairo_content_t			 content);
+
+cairo_private void
+_cairo_surface_set_font_options (cairo_surface_t       *surface,
+				 cairo_font_options_t  *options);
+
+cairo_private cairo_clip_mode_t
+_cairo_surface_get_clip_mode (cairo_surface_t *surface);
+
+cairo_private cairo_status_t
+_cairo_surface_composite (cairo_operator_t	op,
+			  cairo_pattern_t	*src,
+			  cairo_pattern_t	*mask,
+			  cairo_surface_t	*dst,
+			  int			src_x,
+			  int			src_y,
+			  int			mask_x,
+			  int			mask_y,
+			  int			dst_x,
+			  int			dst_y,
+			  unsigned int		width,
+			  unsigned int		height);
+
+cairo_private cairo_status_t
+_cairo_surface_fill_rectangle (cairo_surface_t	   *surface,
+			       cairo_operator_t	    op,
+			       const cairo_color_t *color,
+			       int		    x,
+			       int		    y,
+			       int		    width,
+			       int		    height);
+
+cairo_private cairo_status_t
+_cairo_surface_fill_region (cairo_surface_t	   *surface,
+			    cairo_operator_t	    op,
+			    const cairo_color_t    *color,
+			    cairo_region_t         *region);
+
+cairo_private cairo_status_t
+_cairo_surface_fill_rectangles (cairo_surface_t		*surface,
+				cairo_operator_t         op,
+				const cairo_color_t	*color,
+				cairo_rectangle_int_t	*rects,
+				int			 num_rects);
+
+cairo_private cairo_status_t
+_cairo_surface_paint (cairo_surface_t	*surface,
+		      cairo_operator_t	 op,
+		      cairo_pattern_t	*source);
+
+cairo_private cairo_status_t
+_cairo_surface_mask (cairo_surface_t	*surface,
+		     cairo_operator_t	 op,
+		     cairo_pattern_t	*source,
+		     cairo_pattern_t	*mask);
+
+cairo_private cairo_status_t
+_cairo_surface_fill_stroke (cairo_surface_t	    *surface,
+			    cairo_operator_t	     fill_op,
+			    cairo_pattern_t	    *fill_source,
+			    cairo_fill_rule_t	     fill_rule,
+			    double		     fill_tolerance,
+			    cairo_antialias_t	     fill_antialias,
+			    cairo_path_fixed_t	    *path,
+			    cairo_operator_t	     stroke_op,
+			    cairo_pattern_t	    *stroke_source,
+			    cairo_stroke_style_t    *stroke_style,
+			    cairo_matrix_t	    *stroke_ctm,
+			    cairo_matrix_t	    *stroke_ctm_inverse,
+			    double		     stroke_tolerance,
+			    cairo_antialias_t	     stroke_antialias);
+
+cairo_private cairo_status_t
+_cairo_surface_stroke (cairo_surface_t		*surface,
+		       cairo_operator_t		 op,
+		       cairo_pattern_t		*source,
+		       cairo_path_fixed_t	*path,
+		       cairo_stroke_style_t	*style,
+		       cairo_matrix_t		*ctm,
+		       cairo_matrix_t		*ctm_inverse,
+		       double			 tolerance,
+		       cairo_antialias_t	 antialias);
+
+cairo_private cairo_status_t
+_cairo_surface_fill (cairo_surface_t	*surface,
+		     cairo_operator_t	 op,
+		     cairo_pattern_t	*source,
+		     cairo_path_fixed_t	*path,
+		     cairo_fill_rule_t	 fill_rule,
+		     double		 tolerance,
+		     cairo_antialias_t	 antialias);
+
+cairo_private cairo_status_t
+_cairo_surface_show_text_glyphs (cairo_surface_t	    *surface,
+				 cairo_operator_t	     op,
+				 cairo_pattern_t	    *source,
+				 const char		    *utf8,
+				 int			     utf8_len,
+				 cairo_glyph_t		    *glyphs,
+				 int			     num_glyphs,
+				 const cairo_text_cluster_t *clusters,
+				 int			     num_clusters,
+				 cairo_text_cluster_flags_t  cluster_flags,
+				 cairo_scaled_font_t	    *scaled_font);
+
+cairo_private cairo_status_t
+_cairo_surface_composite_trapezoids (cairo_operator_t	op,
+				     cairo_pattern_t	*pattern,
+				     cairo_surface_t	*dst,
+				     cairo_antialias_t	antialias,
+				     int		src_x,
+				     int		src_y,
+				     int		dst_x,
+				     int		dst_y,
+				     unsigned int	width,
+				     unsigned int	height,
+				     cairo_trapezoid_t	*traps,
+				     int		ntraps);
+
+cairo_private cairo_status_t
+_cairo_surface_acquire_source_image (cairo_surface_t         *surface,
+				     cairo_image_surface_t  **image_out,
+				     void                   **image_extra);
+
+cairo_private void
+_cairo_surface_release_source_image (cairo_surface_t        *surface,
+				     cairo_image_surface_t  *image,
+				     void                   *image_extra);
+
+cairo_private cairo_status_t
+_cairo_surface_acquire_dest_image (cairo_surface_t         *surface,
+				   cairo_rectangle_int_t   *interest_rect,
+				   cairo_image_surface_t  **image_out,
+				   cairo_rectangle_int_t   *image_rect,
+				   void                   **image_extra);
+
+cairo_private void
+_cairo_surface_release_dest_image (cairo_surface_t        *surface,
+				   cairo_rectangle_int_t  *interest_rect,
+				   cairo_image_surface_t  *image,
+				   cairo_rectangle_int_t  *image_rect,
+				   void                   *image_extra);
+
+cairo_private cairo_status_t
+_cairo_surface_clone_similar (cairo_surface_t  *surface,
+			      cairo_surface_t  *src,
+			      int               src_x,
+			      int               src_y,
+			      int               width,
+			      int               height,
+			      int              *clone_offset_x,
+			      int              *clone_offset_y,
+			      cairo_surface_t **clone_out);
+
+cairo_private cairo_surface_t *
+_cairo_surface_snapshot (cairo_surface_t *surface);
+
+cairo_private cairo_bool_t
+_cairo_surface_is_similar (cairo_surface_t *surface_a,
+	                   cairo_surface_t *surface_b,
+			   cairo_content_t  content);
+
+cairo_private cairo_status_t
+_cairo_surface_reset (cairo_surface_t *surface);
+
+cairo_private unsigned int
+_cairo_surface_get_current_clip_serial (cairo_surface_t *surface);
+
+cairo_private unsigned int
+_cairo_surface_allocate_clip_serial (cairo_surface_t *surface);
+
+cairo_private cairo_status_t
+_cairo_surface_reset_clip (cairo_surface_t *surface);
+
+cairo_private cairo_status_t
+_cairo_surface_set_clip_region (cairo_surface_t	    *surface,
+				cairo_region_t      *region,
+				unsigned int	    serial);
+
+cairo_private cairo_int_status_t
+_cairo_surface_intersect_clip_path (cairo_surface_t    *surface,
+				    cairo_path_fixed_t *path,
+				    cairo_fill_rule_t   fill_rule,
+				    double		tolerance,
+				    cairo_antialias_t	antialias);
+
+cairo_private cairo_clip_t *
+_cairo_surface_get_clip (cairo_surface_t *surface);
+
+cairo_private cairo_status_t
+_cairo_surface_set_clip (cairo_surface_t *surface, cairo_clip_t *clip);
+
+cairo_private cairo_int_status_t
+_cairo_surface_get_extents (cairo_surface_t         *surface,
+			    cairo_rectangle_int_t   *extents);
+
+cairo_private cairo_status_t
+_cairo_surface_old_show_glyphs (cairo_scaled_font_t	*scaled_font,
+				cairo_operator_t	 op,
+				cairo_pattern_t		*pattern,
+				cairo_surface_t		*surface,
+				int			 source_x,
+				int			 source_y,
+				int			 dest_x,
+				int			 dest_y,
+				unsigned int		 width,
+				unsigned int		 height,
+				cairo_glyph_t		*glyphs,
+				int			 num_glyphs);
+
+cairo_private cairo_status_t
+_cairo_surface_composite_fixup_unbounded (cairo_surface_t            *dst,
+					  cairo_surface_attributes_t *src_attr,
+					  int                         src_width,
+					  int                         src_height,
+					  cairo_surface_attributes_t *mask_attr,
+					  int                         mask_width,
+					  int                         mask_height,
+					  int			      src_x,
+					  int			      src_y,
+					  int			      mask_x,
+					  int			      mask_y,
+					  int			      dst_x,
+					  int			      dst_y,
+					  unsigned int		      width,
+					  unsigned int		      height);
+
+cairo_private cairo_status_t
+_cairo_surface_composite_shape_fixup_unbounded (cairo_surface_t            *dst,
+						cairo_surface_attributes_t *src_attr,
+						int                         src_width,
+						int                         src_height,
+						int                         mask_width,
+						int                         mask_height,
+						int			    src_x,
+						int			    src_y,
+						int			    mask_x,
+						int			    mask_y,
+						int			    dst_x,
+						int			    dst_y,
+						unsigned int		    width,
+						unsigned int		    height);
+
+cairo_private cairo_bool_t
+_cairo_surface_is_opaque (const cairo_surface_t *surface);
+
+cairo_private void
+_cairo_surface_set_device_scale (cairo_surface_t *surface,
+				 double		  sx,
+				 double		  sy);
+
+cairo_private cairo_bool_t
+_cairo_surface_has_device_transform (cairo_surface_t *surface);
+
+/* cairo-image-surface.c */
+
+/* XXX: In cairo 1.2.0 we added a new %CAIRO_FORMAT_RGB16_565 but
+ * neglected to adjust this macro. The net effect is that it's
+ * impossible to externally create an image surface with this
+ * format. This is perhaps a good thing since we also neglected to fix
+ * up things like cairo_surface_write_to_png() for the new format
+ * (-Wswitch-enum will tell you where). Is it obvious that format was
+ * added in haste?
+ *
+ * The reason for the new format was to allow the xlib backend to be
+ * used on X servers with a 565 visual. So the new format did its job
+ * for that, even without being considered "valid" for the sake of
+ * things like cairo_image_surface_create().
+ *
+ * Since 1.2.0 we ran into the same situtation with X servers with BGR
+ * visuals. This time we invented #cairo_internal_format_t instead,
+ * (see it for more discussion).
+ *
+ * The punchline is that %CAIRO_FORMAT_VALID must not conside any
+ * internal format to be valid. Also we need to decide if the
+ * RGB16_565 should be moved to instead be an internal format. If so,
+ * this macro need not change for it. (We probably will need to leave
+ * an RGB16_565 value in the header files for the sake of code that
+ * might have that value in it.)
+ *
+ * If we do decide to start fully supporting RGB16_565 as an external
+ * format, then %CAIRO_FORMAT_VALID needs to be adjusted to include
+ * it. But that should not happen before all necessary code is fixed
+ * to support it (at least cairo_surface_write_to_png() and a few spots
+ * in cairo-xlib-surface.c--again see -Wswitch-enum).
+ */
+#define CAIRO_FORMAT_INVALID ((unsigned int) -1)
+#define CAIRO_FORMAT_VALID(format) ((format) <= CAIRO_FORMAT_A1)
+
+/* pixman-required stride alignment in bytes. */
+#define CAIRO_STRIDE_ALIGNMENT (sizeof (uint32_t))
+#define CAIRO_STRIDE_FOR_WIDTH_BPP(w,bpp) \
+   (((bpp)*(w)+7)/8 + CAIRO_STRIDE_ALIGNMENT-1) & ~(CAIRO_STRIDE_ALIGNMENT-1)
+
+#define CAIRO_CONTENT_VALID(content) ((content) && 			         \
+				      (((content) & ~(CAIRO_CONTENT_COLOR |      \
+						      CAIRO_CONTENT_ALPHA |      \
+						      CAIRO_CONTENT_COLOR_ALPHA))\
+				       == 0))
+
+cairo_private int
+_cairo_format_bits_per_pixel (cairo_format_t format);
+
+cairo_private cairo_format_t
+_cairo_format_from_content (cairo_content_t content);
+
+cairo_private cairo_content_t
+_cairo_content_from_format (cairo_format_t format);
+
+cairo_private cairo_surface_t *
+_cairo_image_surface_create_for_pixman_image (pixman_image_t		*pixman_image,
+					      pixman_format_code_t	 pixman_format);
+
+cairo_private cairo_bool_t
+_pixman_format_from_masks (cairo_format_masks_t *masks,
+			   pixman_format_code_t *format_ret);
+
+cairo_private void
+_pixman_format_to_masks (pixman_format_code_t	 pixman_format,
+			 cairo_format_masks_t	*masks);
+
+cairo_private cairo_surface_t *
+_cairo_image_surface_create_with_pixman_format (unsigned char		*data,
+						pixman_format_code_t	 pixman_format,
+						int			 width,
+						int			 height,
+						int			 stride);
+
+cairo_private cairo_surface_t *
+_cairo_image_surface_create_with_masks (unsigned char	       *data,
+					cairo_format_masks_t   *format,
+					int			width,
+					int			height,
+					int			stride);
+
+cairo_private cairo_surface_t *
+_cairo_image_surface_create_with_content (cairo_content_t	content,
+					  int			width,
+					  int			height);
+
+cairo_private cairo_surface_t *
+_cairo_image_surface_create_for_data_with_content (unsigned char	*data,
+						   cairo_content_t	 content,
+						   int			 width,
+						   int			 height,
+						   int			 stride);
+
+cairo_private void
+_cairo_image_surface_assume_ownership_of_data (cairo_image_surface_t *surface);
+
+/* XXX: It's a nasty kludge that this appears here. Backend functions
+ * like this should really be static. But we're doing this to work
+ * around some general defects in the backend clipping interfaces,
+ * (see some notes in test-paginated-surface.c).
+ *
+ * I want to fix the real defects, but it's "hard" as they touch many
+ * backends, so doing that will require synchronizing several backend
+ * maintainers.
+ */
+cairo_private cairo_int_status_t
+_cairo_image_surface_set_clip_region (void *abstract_surface,
+				      cairo_region_t *region);
+
+cairo_private cairo_image_surface_t *
+_cairo_image_surface_clone (cairo_image_surface_t	*surface,
+			    cairo_format_t		 format);
+
+cairo_private cairo_image_transparency_t
+_cairo_image_analyze_transparency (cairo_image_surface_t      *image);
+
+cairo_private cairo_bool_t
+_cairo_surface_is_image (const cairo_surface_t *surface);
+
+cairo_private cairo_bool_t
+_cairo_surface_is_meta (const cairo_surface_t *surface);
+
+/* cairo-pen.c */
+cairo_private cairo_status_t
+_cairo_pen_init (cairo_pen_t	*pen,
+		 double		 radius,
+		 double		 tolerance,
+		 cairo_matrix_t	*ctm);
+
+cairo_private void
+_cairo_pen_init_empty (cairo_pen_t *pen);
+
+cairo_private cairo_status_t
+_cairo_pen_init_copy (cairo_pen_t *pen, cairo_pen_t *other);
+
+cairo_private void
+_cairo_pen_fini (cairo_pen_t *pen);
+
+cairo_private cairo_status_t
+_cairo_pen_add_points (cairo_pen_t *pen, cairo_point_t *point, int num_points);
+
+cairo_private cairo_status_t
+_cairo_pen_add_points_for_slopes (cairo_pen_t *pen,
+				  cairo_point_t *a,
+				  cairo_point_t *b,
+				  cairo_point_t *c,
+				  cairo_point_t *d);
+
+cairo_private void
+_cairo_pen_find_active_cw_vertex_index (cairo_pen_t *pen,
+					cairo_slope_t *slope,
+					int *active);
+
+cairo_private void
+_cairo_pen_find_active_ccw_vertex_index (cairo_pen_t *pen,
+					 cairo_slope_t *slope,
+					 int *active);
+
+cairo_private cairo_status_t
+_cairo_pen_stroke_spline (cairo_pen_t *pen,
+			  cairo_spline_t *spline,
+			  double tolerance,
+			  cairo_traps_t *traps);
+
+/* cairo-polygon.c */
+cairo_private void
+_cairo_polygon_init (cairo_polygon_t *polygon);
+
+cairo_private void
+_cairo_polygon_fini (cairo_polygon_t *polygon);
+
+cairo_private void
+_cairo_polygon_move_to (cairo_polygon_t *polygon,
+			const cairo_point_t *point);
+
+cairo_private void
+_cairo_polygon_line_to (cairo_polygon_t *polygon,
+			const cairo_point_t *point);
+
+cairo_private void
+_cairo_polygon_close (cairo_polygon_t *polygon);
+
+#define _cairo_polygon_status(P) (P)->status
+
+/* cairo-spline.c */
+cairo_private cairo_int_status_t
+_cairo_spline_init (cairo_spline_t *spline,
+		    const cairo_point_t *a,
+		    const cairo_point_t *b,
+		    const cairo_point_t *c,
+		    const cairo_point_t *d);
+
+cairo_private cairo_status_t
+_cairo_spline_decompose (cairo_spline_t *spline, double tolerance);
+
+cairo_private void
+_cairo_spline_fini (cairo_spline_t *spline);
+
+/* cairo-matrix.c */
+cairo_private void
+_cairo_matrix_get_affine (const cairo_matrix_t *matrix,
+			  double *xx, double *yx,
+			  double *xy, double *yy,
+			  double *x0, double *y0);
+
+cairo_private void
+_cairo_matrix_transform_bounding_box (const cairo_matrix_t *matrix,
+				      double *x1, double *y1,
+				      double *x2, double *y2,
+				      cairo_bool_t *is_tight);
+
+cairo_private void
+_cairo_matrix_transform_bounding_box_fixed (const cairo_matrix_t *matrix,
+					    cairo_box_t          *bbox,
+					    cairo_bool_t         *is_tight);
+
+cairo_private cairo_bool_t
+_cairo_matrix_is_invertible (const cairo_matrix_t *matrix);
+
+cairo_private double
+_cairo_matrix_compute_determinant (const cairo_matrix_t *matrix);
+
+cairo_private cairo_status_t
+_cairo_matrix_compute_basis_scale_factors (const cairo_matrix_t *matrix,
+				     double *sx, double *sy, int x_major);
+
+cairo_private cairo_bool_t
+_cairo_matrix_is_identity (const cairo_matrix_t *matrix);
+
+cairo_private cairo_bool_t
+_cairo_matrix_is_translation (const cairo_matrix_t *matrix);
+
+cairo_private cairo_bool_t
+_cairo_matrix_is_integer_translation(const cairo_matrix_t *matrix,
+				     int *itx, int *ity);
+
+cairo_private cairo_bool_t
+_cairo_matrix_is_pixel_exact (const cairo_matrix_t *matrix);
+
+cairo_private double
+_cairo_matrix_transformed_circle_major_axis(cairo_matrix_t *matrix, double radius);
+
+cairo_private void
+_cairo_matrix_to_pixman_matrix (const cairo_matrix_t	*matrix,
+				pixman_transform_t	*pixman_transform);
+
+/* cairo-traps.c */
+cairo_private void
+_cairo_traps_init (cairo_traps_t *traps);
+
+cairo_private void
+_cairo_traps_limit (cairo_traps_t	*traps,
+		    cairo_box_t		*limits);
+
+cairo_private cairo_bool_t
+_cairo_traps_get_limit (cairo_traps_t *traps,
+                        cairo_box_t   *limits);
+
+cairo_private void
+_cairo_traps_init_box (cairo_traps_t *traps,
+		       const cairo_box_t   *box);
+
+cairo_private void
+_cairo_traps_clear (cairo_traps_t *traps);
+
+cairo_private void
+_cairo_traps_fini (cairo_traps_t *traps);
+
+#define _cairo_traps_status(T) (T)->status
+
+cairo_private void
+_cairo_traps_translate (cairo_traps_t *traps, int x, int y);
+
+cairo_private cairo_status_t
+_cairo_traps_tessellate_triangle (cairo_traps_t *traps,
+				  const cairo_point_t t[3]);
+
+cairo_private cairo_status_t
+_cairo_traps_tessellate_convex_quad (cairo_traps_t *traps,
+				     const cairo_point_t q[4]);
+
+cairo_private cairo_status_t
+_cairo_traps_tessellate_rectangle (cairo_traps_t *traps,
+				   const cairo_point_t *top_left,
+				   const cairo_point_t *bottom_right);
+
+cairo_private void
+_cairo_traps_add_trap (cairo_traps_t *traps,
+		       cairo_fixed_t top, cairo_fixed_t bottom,
+		       cairo_line_t *left, cairo_line_t *right);
+
+cairo_private cairo_status_t
+_cairo_bentley_ottmann_tessellate_polygon (cairo_traps_t         *traps,
+					   const cairo_polygon_t *polygon,
+					   cairo_fill_rule_t      fill_rule);
+
+cairo_private int
+_cairo_traps_contain (const cairo_traps_t *traps,
+		      double x, double y);
+
+cairo_private void
+_cairo_traps_extents (const cairo_traps_t *traps,
+		      cairo_box_t         *extents);
+
+cairo_private cairo_int_status_t
+_cairo_traps_extract_region (const cairo_traps_t *tr,
+			     cairo_region_t      *region);
+
+cairo_private cairo_status_t
+_cairo_traps_path (const cairo_traps_t *traps,
+		   cairo_path_fixed_t  *path);
+
+cairo_private void
+_cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
+					    cairo_trapezoid_t *src_traps,
+					    int num_traps,
+					    double tx, double ty,
+					    double sx, double sy);
+
+/* cairo-slope.c */
+cairo_private void
+_cairo_slope_init (cairo_slope_t *slope,
+		   const cairo_point_t *a,
+		   const cairo_point_t *b);
+
+cairo_private int
+_cairo_slope_compare (const cairo_slope_t *a, const cairo_slope_t *b);
+
+/* cairo-pattern.c */
+
+cairo_private cairo_status_t
+_cairo_pattern_create_copy (cairo_pattern_t	  **pattern,
+			    const cairo_pattern_t  *other);
+
+cairo_private cairo_status_t
+_cairo_pattern_init_copy (cairo_pattern_t	*pattern,
+			  const cairo_pattern_t *other);
+
+cairo_private cairo_status_t
+_cairo_pattern_init_snapshot (cairo_pattern_t       *pattern,
+			      const cairo_pattern_t *other);
+
+cairo_private void
+_cairo_pattern_init_solid (cairo_solid_pattern_t	*pattern,
+			   const cairo_color_t		*color,
+			   cairo_content_t		 content);
+
+cairo_private void
+_cairo_pattern_init_for_surface (cairo_surface_pattern_t *pattern,
+				 cairo_surface_t *surface);
+
+cairo_private void
+_cairo_pattern_init_linear (cairo_linear_pattern_t *pattern,
+			    double x0, double y0, double x1, double y1);
+
+cairo_private void
+_cairo_pattern_init_radial (cairo_radial_pattern_t *pattern,
+			    double cx0, double cy0, double radius0,
+			    double cx1, double cy1, double radius1);
+
+cairo_private void
+_cairo_pattern_fini (cairo_pattern_t *pattern);
+
+cairo_private cairo_pattern_t *
+_cairo_pattern_create_solid (const cairo_color_t	*color,
+			     cairo_content_t		 content);
+
+cairo_private void
+_cairo_pattern_transform (cairo_pattern_t      *pattern,
+			  const cairo_matrix_t *ctm_inverse);
+
+cairo_private cairo_bool_t
+_cairo_pattern_is_opaque_solid (const cairo_pattern_t *pattern);
+
+cairo_private cairo_bool_t
+_cairo_pattern_is_opaque (const cairo_pattern_t *abstract_pattern);
+
+cairo_private cairo_int_status_t
+_cairo_pattern_acquire_surface (cairo_pattern_t		   *pattern,
+				cairo_surface_t		   *dst,
+				int			   x,
+				int			   y,
+				unsigned int		   width,
+				unsigned int		   height,
+				cairo_surface_t		   **surface_out,
+				cairo_surface_attributes_t *attributes);
+
+cairo_private void
+_cairo_pattern_release_surface (cairo_pattern_t		   *pattern,
+				cairo_surface_t		   *surface,
+				cairo_surface_attributes_t *attributes);
+
+cairo_private cairo_int_status_t
+_cairo_pattern_acquire_surfaces (cairo_pattern_t	    *src,
+				 cairo_pattern_t	    *mask,
+				 cairo_surface_t	    *dst,
+				 int			    src_x,
+				 int			    src_y,
+				 int			    mask_x,
+				 int			    mask_y,
+				 unsigned int		    width,
+				 unsigned int		    height,
+				 cairo_surface_t	    **src_out,
+				 cairo_surface_t	    **mask_out,
+				 cairo_surface_attributes_t *src_attributes,
+				 cairo_surface_attributes_t *mask_attributes);
+
+cairo_private cairo_status_t
+_cairo_pattern_get_extents (cairo_pattern_t	    *pattern,
+			    cairo_rectangle_int_t   *extents);
+
+cairo_private void
+_cairo_pattern_reset_static_data (void);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_antialias (cairo_gstate_t *gstate,
+			     cairo_antialias_t antialias);
+
+cairo_private cairo_antialias_t
+_cairo_gstate_get_antialias (cairo_gstate_t *gstate);
+
+/* cairo-region.c */
+
+#include "cairo-region-private.h"
+
+/* cairo-unicode.c */
+
+cairo_private int
+_cairo_utf8_get_char_validated (const char *p,
+				uint32_t   *unicode);
+
+cairo_private cairo_status_t
+_cairo_utf8_to_ucs4 (const char *str,
+		     int	 len,
+		     uint32_t  **result,
+		     int	*items_written);
+
+cairo_private int
+_cairo_ucs4_to_utf8 (uint32_t    unicode,
+		     char       *utf8);
+
+#if CAIRO_HAS_WIN32_FONT || CAIRO_HAS_QUARTZ_FONT || CAIRO_HAS_PDF_OPERATORS
+# define CAIRO_HAS_UTF8_TO_UTF16 1
+#endif
+#if CAIRO_HAS_UTF8_TO_UTF16
+cairo_private cairo_status_t
+_cairo_utf8_to_utf16 (const char *str,
+		      int	  len,
+		      uint16_t  **result,
+		      int	 *items_written);
+#endif
+
+#define _cairo_status_is_error(status) \
+    (status != CAIRO_STATUS_SUCCESS && status <= CAIRO_STATUS_LAST_STATUS)
+
+cairo_private cairo_status_t
+_cairo_error (cairo_status_t status);
+
+/* hide compiler warnings when discarding the return value */
+#define _cairo_error_throw(status) do { \
+    cairo_status_t status__ = _cairo_error (status); \
+    (void) status__; \
+} while (0)
+
+/* Avoid unnecessary PLT entries.  */
+slim_hidden_proto (cairo_clip_preserve);
+slim_hidden_proto (cairo_close_path);
+slim_hidden_proto (cairo_create);
+slim_hidden_proto (cairo_curve_to);
+slim_hidden_proto (cairo_destroy);
+slim_hidden_proto (cairo_fill_preserve);
+slim_hidden_proto (cairo_font_face_destroy);
+slim_hidden_proto (cairo_font_face_get_user_data);
+slim_hidden_proto_no_warn (cairo_font_face_reference);
+slim_hidden_proto (cairo_font_face_set_user_data);
+slim_hidden_proto (cairo_font_options_equal);
+slim_hidden_proto (cairo_font_options_hash);
+slim_hidden_proto (cairo_font_options_merge);
+slim_hidden_proto (cairo_font_options_set_antialias);
+slim_hidden_proto (cairo_font_options_set_hint_metrics);
+slim_hidden_proto (cairo_font_options_set_hint_style);
+slim_hidden_proto (cairo_font_options_set_subpixel_order);
+slim_hidden_proto (cairo_font_options_status);
+slim_hidden_proto (cairo_get_current_point);
+slim_hidden_proto (cairo_get_line_width);
+slim_hidden_proto (cairo_get_matrix);
+slim_hidden_proto (cairo_get_target);
+slim_hidden_proto (cairo_get_tolerance);
+slim_hidden_proto (cairo_glyph_allocate);
+slim_hidden_proto (cairo_glyph_free);
+slim_hidden_proto (cairo_image_surface_create);
+slim_hidden_proto (cairo_image_surface_create_for_data);
+slim_hidden_proto (cairo_image_surface_get_data);
+slim_hidden_proto (cairo_image_surface_get_height);
+slim_hidden_proto (cairo_image_surface_get_stride);
+slim_hidden_proto (cairo_image_surface_get_width);
+slim_hidden_proto (cairo_format_stride_for_width);
+slim_hidden_proto (cairo_line_to);
+slim_hidden_proto (cairo_mask);
+slim_hidden_proto (cairo_matrix_init);
+slim_hidden_proto (cairo_matrix_init_identity);
+slim_hidden_proto (cairo_matrix_init_rotate);
+slim_hidden_proto (cairo_matrix_init_scale);
+slim_hidden_proto (cairo_matrix_init_translate);
+slim_hidden_proto (cairo_matrix_invert);
+slim_hidden_proto (cairo_matrix_multiply);
+slim_hidden_proto (cairo_matrix_scale);
+slim_hidden_proto (cairo_matrix_transform_distance);
+slim_hidden_proto (cairo_matrix_transform_point);
+slim_hidden_proto (cairo_matrix_translate);
+slim_hidden_proto (cairo_move_to);
+slim_hidden_proto (cairo_new_path);
+slim_hidden_proto (cairo_paint);
+slim_hidden_proto (cairo_path_extents);
+slim_hidden_proto (cairo_pattern_create_for_surface);
+slim_hidden_proto (cairo_pattern_create_rgb);
+slim_hidden_proto (cairo_pattern_create_rgba);
+slim_hidden_proto (cairo_pattern_destroy);
+slim_hidden_proto (cairo_pattern_get_extend);
+slim_hidden_proto (cairo_pattern_get_type);
+slim_hidden_proto_no_warn (cairo_pattern_reference);
+slim_hidden_proto (cairo_pattern_set_matrix);
+slim_hidden_proto (cairo_pattern_status);
+slim_hidden_proto (cairo_pop_group);
+slim_hidden_proto (cairo_pop_group_to_source);
+slim_hidden_proto (cairo_push_group);
+slim_hidden_proto (cairo_push_group_with_content);
+slim_hidden_proto (cairo_rel_line_to);
+slim_hidden_proto (cairo_restore);
+slim_hidden_proto (cairo_save);
+slim_hidden_proto (cairo_scale);
+slim_hidden_proto (cairo_scaled_font_create);
+slim_hidden_proto (cairo_scaled_font_destroy);
+slim_hidden_proto (cairo_scaled_font_extents);
+slim_hidden_proto (cairo_scaled_font_get_ctm);
+slim_hidden_proto (cairo_scaled_font_get_font_face);
+slim_hidden_proto (cairo_scaled_font_get_font_matrix);
+slim_hidden_proto (cairo_scaled_font_get_font_options);
+slim_hidden_proto (cairo_scaled_font_text_to_glyphs);
+slim_hidden_proto (cairo_scaled_font_glyph_extents);
+slim_hidden_proto_no_warn (cairo_scaled_font_reference);
+slim_hidden_proto (cairo_scaled_font_status);
+slim_hidden_proto (cairo_set_font_size);
+slim_hidden_proto (cairo_set_font_options);
+slim_hidden_proto (cairo_set_line_cap);
+slim_hidden_proto (cairo_set_line_join);
+slim_hidden_proto (cairo_set_line_width);
+slim_hidden_proto (cairo_set_matrix);
+slim_hidden_proto (cairo_set_operator);
+slim_hidden_proto (cairo_set_source);
+slim_hidden_proto (cairo_set_source);
+slim_hidden_proto (cairo_set_source_surface);
+slim_hidden_proto (cairo_status);
+slim_hidden_proto (cairo_stroke);
+slim_hidden_proto (cairo_stroke_preserve);
+slim_hidden_proto (cairo_surface_create_similar);
+slim_hidden_proto (cairo_surface_destroy);
+slim_hidden_proto (cairo_surface_finish);
+slim_hidden_proto (cairo_surface_flush);
+slim_hidden_proto (cairo_surface_get_content);
+slim_hidden_proto (cairo_surface_get_device_offset);
+slim_hidden_proto (cairo_surface_get_font_options);
+slim_hidden_proto (cairo_surface_get_type);
+slim_hidden_proto (cairo_surface_has_show_text_glyphs);
+slim_hidden_proto (cairo_surface_mark_dirty_rectangle);
+slim_hidden_proto_no_warn (cairo_surface_reference);
+slim_hidden_proto (cairo_surface_set_device_offset);
+slim_hidden_proto (cairo_surface_set_fallback_resolution);
+slim_hidden_proto (cairo_surface_copy_page);
+slim_hidden_proto (cairo_surface_show_page);
+slim_hidden_proto (cairo_surface_status);
+slim_hidden_proto (cairo_text_cluster_allocate);
+slim_hidden_proto (cairo_text_cluster_free);
+slim_hidden_proto (cairo_toy_font_face_create);
+slim_hidden_proto (cairo_toy_font_face_get_slant);
+slim_hidden_proto (cairo_toy_font_face_get_weight);
+slim_hidden_proto (cairo_user_font_face_create);
+slim_hidden_proto (cairo_user_font_face_set_init_func);
+slim_hidden_proto (cairo_user_font_face_set_render_glyph_func);
+slim_hidden_proto (cairo_user_font_face_set_unicode_to_glyph_func);
+slim_hidden_proto (cairo_version_string);
+
+#if CAIRO_HAS_PNG_FUNCTIONS
+
+slim_hidden_proto (cairo_surface_write_to_png_stream);
+
+#endif
+
+CAIRO_END_DECLS
+
+#include "cairo-mutex-private.h"
+#include "cairo-fixed-private.h"
+#include "cairo-wideint-private.h"
+#include "cairo-malloc-private.h"
+#include "cairo-hash-private.h"
+
+#endif
diff -Naur cairo-1.8.4-debian-1/src/cairo-surface.c cairo-1.8.4-debian-2/src/cairo-surface.c
--- cairo-1.8.4-debian-1/src/cairo-surface.c	2008-12-04 19:42:59.000000000 +0100
+++ cairo-1.8.4-debian-2/src/cairo-surface.c	2008-12-04 19:47:47.000000000 +0100
@@ -73,6 +73,7 @@
     FALSE,				/* has_font_options */	\
     { CAIRO_ANTIALIAS_DEFAULT,		/* antialias */		\
       CAIRO_SUBPIXEL_ORDER_DEFAULT,	/* subpixel_order */	\
+      CAIRO_LCD_FILTER_DEFAULT,		/* lcd_filter */	\
       CAIRO_HINT_STYLE_DEFAULT,		/* hint_style */	\
       CAIRO_HINT_METRICS_DEFAULT	/* hint_metrics */	\
     }					/* font_options */	\
diff -Naur cairo-1.8.4-debian-1/src/cairo-types-private.h cairo-1.8.4-debian-2/src/cairo-types-private.h
--- cairo-1.8.4-debian-1/src/cairo-types-private.h	2008-12-04 19:42:59.000000000 +0100
+++ cairo-1.8.4-debian-2/src/cairo-types-private.h	2008-12-04 19:47:47.000000000 +0100
@@ -113,9 +113,35 @@
     cairo_bool_t is_snapshot;
 };
 
+
+/**
+ * cairo_lcd_filter_t:
+ * @CAIRO_LCD_FILTER_DEFAULT: Use the default LCD filter for
+ *   font backend and target device
+ * @CAIRO_LCD_FILTER_NONE: Do not perform LCD filtering
+ * @CAIRO_LCD_FILTER_INTRA_PIXEL: Intra-pixel filter
+ * @CAIRO_LCD_FILTER_FIR3: FIR filter with a 3x3 kernel
+ * @CAIRO_LCD_FILTER_FIR5: FIR filter with a 5x5 kernel
+ *
+ * The LCD filter specifies the low-pass filter applied to LCD-optimized
+ * bitmaps generated with an antialiasing mode of %CAIRO_ANTIALIAS_SUBPIXEL.
+ *
+ * Note: This API was temporarily made available in the public
+ * interface during the 1.7.x development series, but was made private
+ * before 1.8.
+ **/
+typedef enum _cairo_lcd_filter {
+    CAIRO_LCD_FILTER_DEFAULT,
+    CAIRO_LCD_FILTER_NONE,
+    CAIRO_LCD_FILTER_INTRA_PIXEL,
+    CAIRO_LCD_FILTER_FIR3,
+    CAIRO_LCD_FILTER_FIR5
+} cairo_lcd_filter_t;
+
 struct _cairo_font_options {
     cairo_antialias_t antialias;
     cairo_subpixel_order_t subpixel_order;
+    cairo_lcd_filter_t lcd_filter;
     cairo_hint_style_t hint_style;
     cairo_hint_metrics_t hint_metrics;
 };
diff -Naur cairo-1.8.4-debian-1/src/cairo-xlib-screen.c cairo-1.8.4-debian-2/src/cairo-xlib-screen.c
--- cairo-1.8.4-debian-1/src/cairo-xlib-screen.c	2008-12-04 19:42:59.000000000 +0100
+++ cairo-1.8.4-debian-2/src/cairo-xlib-screen.c	2008-12-04 19:47:47.000000000 +0100
@@ -150,13 +150,22 @@
     cairo_bool_t xft_antialias;
     int xft_hintstyle;
     int xft_rgba;
+    int xft_lcdfilter;
     cairo_antialias_t antialias;
     cairo_subpixel_order_t subpixel_order;
+    cairo_lcd_filter_t lcd_filter;
     cairo_hint_style_t hint_style;
 
     if (!get_boolean_default (dpy, "antialias", &xft_antialias))
 	xft_antialias = TRUE;
 
+    if (!get_integer_default (dpy, "lcdfilter", &xft_lcdfilter)) {
+	/* -1 is an non-existant Fontconfig constant used to differentiate
+	 * the case when no lcdfilter property is available.
+	 */
+	xft_lcdfilter = -1;
+    }
+
     if (!get_boolean_default (dpy, "hinting", &xft_hinting))
 	xft_hinting = TRUE;
 
@@ -239,6 +248,24 @@
 	subpixel_order = CAIRO_SUBPIXEL_ORDER_DEFAULT;
     }
 
+    switch (xft_lcdfilter) {
+    case FC_LCD_NONE:
+	lcd_filter = CAIRO_LCD_FILTER_NONE;
+	break;
+    case FC_LCD_DEFAULT:
+	lcd_filter = CAIRO_LCD_FILTER_FIR5;
+	break;
+    case FC_LCD_LIGHT:
+	lcd_filter = CAIRO_LCD_FILTER_FIR3;
+	break;
+    case FC_LCD_LEGACY:
+	lcd_filter = CAIRO_LCD_FILTER_INTRA_PIXEL;
+	break;
+    default:
+	lcd_filter = CAIRO_LCD_FILTER_DEFAULT;
+	break;
+    }
+
     if (xft_antialias) {
 	if (subpixel_order == CAIRO_SUBPIXEL_ORDER_DEFAULT)
 	    antialias = CAIRO_ANTIALIAS_GRAY;
@@ -251,6 +278,7 @@
     cairo_font_options_set_hint_style (&info->font_options, hint_style);
     cairo_font_options_set_antialias (&info->font_options, antialias);
     cairo_font_options_set_subpixel_order (&info->font_options, subpixel_order);
+    _cairo_font_options_set_lcd_filter (&info->font_options, lcd_filter);
     cairo_font_options_set_hint_metrics (&info->font_options, CAIRO_HINT_METRICS_ON);
 }
 
